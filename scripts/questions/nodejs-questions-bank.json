{
  "totalQuestions": 50,
  "extractedAt": "2025-12-19T17:41:28.046Z",
  "questions": [
    {
      "id": 1,
      "level": "Junior",
      "title": "What is Node.js?",
      "answer": "Node.js is an open-source, cross-platform JavaScript runtime environment that executes JavaScript code outside of a web browser. Unlike traditional JavaScript, which is primarily used for client-side scripting in web browsers, Node.js enables developers to use JavaScript for server-side scripting to produce dynamic web page content before the page is sent to the user's web browser.",
      "isPremium": false
    },
    {
      "id": 2,
      "level": "Junior",
      "title": "What are some key characteristics of Node.js?",
      "answer": "Event-Driven and Asynchronous: Node.js operates on a non-blocking, event-driven architecture, making it efficient and suitable for scalable and high-performance applications, particularly those involving I/O-intensive operations.\nBuilt on Chrome's V8 JavaScript Engine: Node.js uses Google Chrome's V8 JavaScript engine, which compiles JavaScript directly to native machine code, ensuring fast execution.\nSingle-Threaded Model: Despite being single-threaded, Node.js can handle multiple concurrent connections efficiently due to its event-driven architecture and use of non-blocking I/O operations.\nNPM (Node Package Manager): Node.js comes with a vast library of packages, managed through the Node Package Manager (NPM), making it easy to import and use a wide range of modules and tools contributed by the community.\nCross-Platform: Node.js is cross-platform, meaning it can run on various operating systems like Windows, Linux, Unix, Mac OS X, etc.\nUse in Full-Stack Development: Its ability to use JavaScript both on the client and server-side makes Node.js popular in full-stack development.",
      "isPremium": false
    },
    {
      "id": 3,
      "level": "Junior",
      "title": "What is the difference between Node.js and JavaScript?",
      "answer": "JavaScript:\nNature: JavaScript is a scripting language that was initially designed to run in web browsers. It is used mainly for client-side web development to create interactive web pages and user interfaces.\nEnvironment: Runs primarily in web browsers, but can also be used on servers through environments like Node.js.\nUsage: Used for adding interactive behavior to web pages, manipulating HTML and CSS, and handling user inputs and events.\nNode.js:\nNature: Node.js is a runtime environment that allows JavaScript to be run on the server side. It's not a programming language but an environment that uses JavaScript.\nEnvironment: Runs on the server side, outside of web browsers. It allows JavaScript to interact with I/O devices through its APIs, access databases, and more.\nUsage: Used for building server-side applications, RESTful APIs, and handling backend tasks like file operations, network communication, and database operations.",
      "isPremium": false
    },
    {
      "id": 4,
      "level": "Junior",
      "title": "Mention some benefits of using Node.js.",
      "answer": "Asynchronous, Non-blocking I/O: Enables efficient handling of multiple operations concurrently.\nScalability: Its event-driven architecture supports high concurrency, ideal for real-time applications.\nUnified JavaScript Development: Allows using JavaScript for both server-side and client-side, streamlining development.\nLarge Ecosystem: Features a vast library of modules accessible via Node Package Manager (NPM).\nFast Performance: Utilizes Google's V8 JavaScript engine for rapid execution of code.\nCross-platform Compatibility: Facilitates development across different operating systems.\nStrong Community Support: Backed by a robust and active community and corporate sponsorship.\nSuitable for Microservices: Well-adapted for building microservices architecture due to its lightweight nature.",
      "isPremium": false
    },
    {
      "id": 5,
      "level": "Junior",
      "title": "Mention some disadvantages of using Node.js.",
      "answer": "Performance with CPU-intensive Tasks: Node.js is less efficient when handling CPU-intensive tasks due to its single-threaded nature. In such cases, CPU-bound operations can block the event loop, leading to performance issues.\nCallback Hell: Asynchronous programming patterns in Node.js can lead to complex nested callbacks, often referred to as \"callback hell,\" making the code hard to read and maintain.\nLack of Consistent Conventions: With its open-source nature, Node.js can suffer from a lack of consistent coding standards and conventions, which can affect code quality and maintainability.\nAsynchronous Programming Complexity: The asynchronous nature of Node.js, while beneficial for I/O operations, can introduce complexity in code logic, making it challenging for developers who are accustomed to linear, synchronous code execution.",
      "isPremium": false
    },
    {
      "id": 6,
      "level": "Junior",
      "title": "What is the package.json file?",
      "answer": "The package.json file in Node.js projects is a JSON-formatted file that contains metadata about the project, such as its name, version, and description.\nIt also lists project dependencies, defines scripts for common tasks, and may include additional configuration settings. This file plays a crucial role in managing the project's environment and dependencies.",
      "isPremium": false
    },
    {
      "id": 7,
      "level": "Junior",
      "title": "What is NODE_ENV used for?",
      "answer": "NODE_ENV in Node.js is used to indicate the environment (like 'development', 'test', or 'production') in which the application is running.\nThis helps in configuring the application's behavior based on the environment, such as enabling verbose logging in development or optimizing performance in production.\nExample:\n\njavascript\n\nCopy code\n\nif (process.env.NODE_ENV === 'development') {\n    console.log('Logging in development mode');\n}",
      "isPremium": false
    },
    {
      "id": 8,
      "level": "Junior",
      "title": "What is NPM?",
      "answer": "NPM stands for Node Package Manager. It's a key part of the Node.js ecosystem and serves as the following:\n\nPackage Manager: NPM manages packages (or modules) for Node.js. It allows developers to install, update, and manage dependencies for their Node.js applications easily.\nOnline Repository: NPM hosts a large repository of public and private packages, making it a central hub for Node.js libraries and applications.\nCommand-Line Utility: Through its CLI (Command-Line Interface), NPM provides tools for installing and managing packages, as well as controlling various aspects of the Node.js application development.",
      "isPremium": false
    },
    {
      "id": 9,
      "level": "Junior",
      "title": "What are the modules in Node.js?",
      "answer": "Modules in Node.js are individual units of code that encapsulate functionality. They can be core modules provided by Node.js, custom modules written by developers, or third-party modules installed from npm.\nModules are imported using import or require() and can export objects, functions, or variables for use in other parts of an application. They facilitate code organization, reusability, and maintenance.",
      "isPremium": false
    },
    {
      "id": 10,
      "level": "Junior",
      "title": "How would you describe the term I/O?",
      "answer": "The term I/O, short for Input/Output, refers to the transfer of data to and from a computing system. Input is the data received by the system, and Output is the data sent from it. This encompasses a range of activities, such as reading from or writing to storage devices, and receiving or sending data over a network.\nEfficient I/O handling is vital for software performance, particularly in server environments and data-intensive applications.",
      "isPremium": false
    },
    {
      "id": 11,
      "level": "Mid",
      "title": "Why is Node.js Single-threaded?",
      "answer": "Node.js is single-threaded to simplify handling of I/O operations and to improve efficiency. This design allows for easy management of asynchronous events and reduces issues common in multi-threaded environments, such as deadlocks and race conditions.\nDespite its single-threaded nature, Node.js can handle high concurrency through its event-driven architecture and non-blocking I/O model.",
      "isPremium": false
    },
    {
      "id": 12,
      "level": "Mid",
      "title": "If Node.js is single-threaded, then how does it handle concurrency?",
      "answer": "Node.js handles concurrency despite being single-threaded by using an event loop and non-blocking I/O operations. The event loop allows Node.js to perform other tasks while waiting for I/O operations to complete, and then handles the results with callbacks, promises, or async/await.\nThis model enables efficient management of multiple simultaneous operations, making Node.js suitable for high I/O applications. Additionally, for CPU-intensive tasks, Node.js can utilize worker threads to execute JavaScript in parallel threads.",
      "isPremium": false
    },
    {
      "id": 13,
      "level": "Mid",
      "title": "What is the event loop in Node.js?",
      "answer": "The event loop is a fundamental component of Node.js, allowing it to handle asynchronous operations efficiently. Here's a concise explanation:\n\nCore Mechanism: The event loop is what enables Node.js to perform non-blocking I/O operations, despite JavaScript being single-threaded. It's at the heart of Node.js's concurrency model.\nHandling Asynchronous Events: When Node.js needs to execute a task that may take a while to complete (like reading from a file), instead of waiting for the task to finish, it registers an event and a callback function. The event loop keeps running, handling other tasks.\nExecution Order: Once the I/O operation or the task is complete, the event loop retrieves the callback associated with that task and executes it. This system allows Node.js to handle numerous operations concurrently, without waiting for each one to complete before moving on to the next.\nPhases of the Event Loop: The event loop in Node.js has several phases, such as polling for new events, executing callbacks registered with setImmediate(), handling I/O callbacks, and managing timers set with setTimeout() and setInterval().\nEfficiency in I/O Heavy Tasks: The event loop makes Node.js particularly efficient for I/O-heavy tasks, as it can handle many operations in the background and respond to them as soon as they're ready.",
      "isPremium": false
    },
    {
      "id": 14,
      "level": "Mid",
      "title": "What does event-driven programming mean?",
      "answer": "Event-driven programming is a programming paradigm in which the flow of the program is determined by events such as user actions (mouse clicks, keyboard presses), sensor outputs, or messages from other programs/threads.\nCharacteristic features:\nEvent Handlers: In this paradigm, the program responds to different events using event handlers or listener functions. When an event occurs, the corresponding handler function is executed.\nAsynchronous Behavior: Event-driven programming is inherently asynchronous. Instead of executing code in a linear sequence, operations are typically triggered by events and handled independently.\nLoose Coupling: This style often results in a program structure where the components are loosely coupled. They don't call each other directly but instead communicate via events, which can enhance flexibility and scalability.\nReactive Approach: The program waits and listens for events to occur and reacts accordingly, rather than following a predetermined path of execution.",
      "isPremium": false
    },
    {
      "id": 15,
      "level": "Mid",
      "title": "What is an EventEmitter in Node.js?",
      "answer": "In Node.js, an EventEmitter is part of the events module and is used to handle and emit custom events. It allows you to set up event listeners with .on() or .addListener(), and trigger those listeners by emitting events with .emit().\nThis mechanism is key for creating and handling custom events in an asynchronous way, making it essential in event-driven programming in Node.js.\nExample:\n\njavascript\n\nCopy code\n\nconst EventEmitter = require('events');\n \n// Create an emitter class\nclass MyEmitter extends EventEmitter {}\n \n// Initialize an emitter object\nconst myEmitter = new MyEmitter();\n \n// Add an event listener\nmyEmitter.on('event', () => {\n  console.log('An event occurred!');\n});\n \n// Emit an event\nmyEmitter.emit('event');\nIn this example, we create a new EventEmitter instance, add a listener for an 'event', and then emit 'event', triggering the listener function.",
      "isPremium": false
    },
    {
      "id": 16,
      "level": "Mid",
      "title": "What is the difference between process.nextTick() and setImmediate()?",
      "answer": "process.nextTick() schedules a callback to be invoked in the next iteration of the event loop, prioritizing it over other events like I/O.\nsetImmediate() schedules a callback to execute after the current event loop cycle, typically after I/O events.\nThus, process.nextTick() callbacks tend to execute before those scheduled with setImmediate().\nExample:\n\njavascript\n\nCopy code\n\n// Example using setImmediate\nsetImmediate(() => {\n    console.log('Executed with setImmediate');\n});\n \n// Example using process.nextTick\nprocess.nextTick(() => {\n    console.log('Executed with process.nextTick');\n});\n \nconsole.log('Started');\n \n// OUTPUT:\n// Started\n// Executed with process.nextTick\n// Executed with setImmediate",
      "isPremium": false
    },
    {
      "id": 17,
      "level": "Mid",
      "title": "Explain non-blocking in Node.js.",
      "answer": "Non-blocking in Node.js refers to its capability to perform operations like I/O asynchronously. This means Node.js can initiate an operation and then move on to execute other code without waiting for the operation to complete.\nThe results are handled via callbacks, promises, or async/await, allowing Node.js to efficiently manage multiple tasks concurrently. This approach enhances the performance and scalability of applications, particularly in handling numerous I/O operations.",
      "isPremium": false
    },
    {
      "id": 18,
      "level": "Mid",
      "title": "What is a callback in Node.js?",
      "answer": "In Node.js, a callback is a function passed as an argument to another function and is executed after a certain operation completes. This is a key part of handling asynchronous operations in Node.js, enabling non-blocking execution.\nExample:\n\njavascript\n\nCopy code\n\nconst fs = require('fs');\n \n// Read a file asynchronously\nfs.readFile('example.txt', 'utf8', (err, data) => {\n    if (err) {\n        console.error(\"Error reading file:\", err);\n        return;\n    }\n    console.log(data);\n});\n\nIn this example, fs.readFile is an asynchronous function that reads a file. The third argument is a callback function that gets executed after the file is read. The callback receives two parameters, an error err (if any occurred) and the file data data. This pattern allows the rest of the code to run without waiting for the file read operation to complete.",
      "isPremium": false
    },
    {
      "id": 19,
      "level": "Mid",
      "title": "What are the advantages of using promises instead of callbacks?",
      "answer": "Readability: They lead to cleaner and more structured code, reducing the complexity seen in nested callback patterns.\nError Handling: Promises provide a streamlined approach for error handling with .catch(), avoiding repetitive error checks in each callback.\nChaining: Promises can be easily chained, allowing for sequential and clear execution of asynchronous tasks.\nControl Over Asynchronous Operations: They offer methods like Promise.all() to manage multiple asynchronous operations more effectively.",
      "isPremium": false
    },
    {
      "id": 20,
      "level": "Mid",
      "title": "What is “callback hell” and how can it be avoided?",
      "answer": "\"Callback hell\" in Node.js refers to deeply nested and hard-to-read callback functions common in asynchronous programming. It can be avoided by:\nModularization: Breaking down complex functions into smaller, manageable ones.\nUsing Promises: They provide a cleaner way to handle asynchronous operations with .then() and .catch() methods.\nAsync/Await Syntax: Makes asynchronous code more readable and easier to follow.",
      "isPremium": false
    },
    {
      "id": 21,
      "level": "Mid",
      "title": "Explain REPL in Node.js.",
      "answer": "REPL stands for Read-Eval-Print Loop, and it's an interactive programming environment in Node.js. Here's a concise explanation:\n\nInteractive Environment: REPL in Node.js provides an interactive shell that allows you to execute JavaScript code and see the results immediately.\nComponents:\nRead: Reads the user's input, parses it into JavaScript data structures, and then stores it in memory.\nEval: Executes the parsed JavaScript code and evaluates the result.\nPrint: Prints the result of the evaluated code to the console.\nLoop: Loops back to the read phase, waiting for new user input.\nUsage: It's commonly used for experimenting with Node.js code, debugging, or learning purposes. You can test code snippets rapidly without needing to write a complete script.\nStarting REPL: It can be initiated by simply running the node command without any arguments in the command line.",
      "isPremium": false
    },
    {
      "id": 22,
      "level": "Mid",
      "title": "What is the syntax to import external libraries into Node.js projects?",
      "answer": "There are two primary ways to import external libraries in Node.js projects:\nThe require() function with the library's name as an argument.\n\njavascript\n\nCopy code\n\nconst libraryName = require('libraryName');\nconst express = require('express');\nThe import statement, a feature from ECMAScript 6 (ES6).\n\njavascript\n\nCopy code\n\nimport libraryName from 'libraryName';\nimport express from 'express';",
      "isPremium": false
    },
    {
      "id": 23,
      "level": "Mid",
      "title": "Name some of the most commonly used libraries in Node.js?",
      "answer": "Express.js: A fast, unopinionated, minimalist web framework for Node.js, often used to build web applications and APIs.\nMongoose: A MongoDB object modeling tool designed to work in an asynchronous environment, simplifying interactions with MongoDB databases.\nAsync: A utility module that provides straightforward, powerful functions for working with asynchronous JavaScript.\nLodash: A modern JavaScript utility library delivering modularity, performance, & extras, widely used for working with arrays, numbers, objects, strings, etc.\nMoment.js: A library for parsing, validating, manipulating, and displaying dates and times in JavaScript.\nSocket.io: Enables real-time bidirectional event-based communication, commonly used for chat applications and real-time analytics.\nAxios: A Promise-based HTTP client for the browser and Node.js, popular for making HTTP requests.\nPassport: A middleware for Node.js, extremely flexible and modular, used for implementing user authentication.",
      "isPremium": false
    },
    {
      "id": 24,
      "level": "Mid",
      "title": "How do you create a simple Express.js application?",
      "answer": "Initialize a Node.js project with npm init and create a package.json file.\nInstall Express with npm install express.\nCreate a file (e.g., app.js) and write the basic Express setup:\n\njavascript\n\nCopy code\n\nconst express = require('express');\nconst app = express();\n \napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n \napp.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\nStart the server with node app.js and access it at http://localhost:3000.",
      "isPremium": false
    },
    {
      "id": 25,
      "level": "Mid",
      "title": "Explain routing in Express.",
      "answer": "Routing in Express.js defines how an application responds to client requests at specific endpoints. It involves specifying paths, HTTP methods, and handling logic for each route.\nExample:\n\njavascript\n\nCopy code\n\nconst express = require('express');\nconst app = express();\n \n// Define a route\napp.get('/hello', (req, res) => {\n  res.send('Hello World!');\n});\n \napp.listen(3000, () => {\n  console.log('Server started on port 3000');\n});\nIn this example, a route is defined for GET requests to '/hello', which responds with 'Hello World!'. This showcases the basic setup for handling a route in Express.js.",
      "isPremium": false
    },
    {
      "id": 26,
      "level": "Mid",
      "title": "Explain the reason as to why Express ‘app’ and ‘server’ must be kept separate.",
      "answer": "Separating the Express 'app' (handling routes and middleware) from the 'server' (managing the HTTP server) in Node.js is recommended for improved testability, flexibility in deployment, and maintainability. It allows for easier testing of the app logic, provides options for different server configurations, and supports scalability and code manageability.\nThis separation also facilitates the integration of advanced server features without altering the application logic. This approach leads to a cleaner and more modular application structure.\nExample:\n\njavascript\n\nCopy code\n\n// app.js - Defining the Express application\nconst express = require('express');\nconst app = express();\n \napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n \nmodule.exports = app;\n \n// server.js - Setting up the server\nconst app = require('./app');\nconst server = app.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\nIn this structure, app.js contains the Express application logic, while server.js handles the server configuration and startup. This separation enhances testability, scalability, and maintainability of the application.",
      "isPremium": false
    },
    {
      "id": 27,
      "level": "Mid",
      "title": "Describe the exit codes of Node.js.",
      "answer": "In Node.js, exit codes are numerical codes returned by processes upon their completion, used to indicate whether the process exited successfully or encountered an error. Commonly used exit codes include:\n0: Successful completion. The default code when a process exits without errors.\n1: Uncaught Fatal Exception. Indicates the process was terminated due to an unhandled exception.\n2: Reserved. Generally indicates misuse of shell built-ins.",
      "isPremium": false
    },
    {
      "id": 28,
      "level": "Mid",
      "title": "Explain control flow in Node.js.",
      "answer": "Control flow in Node.js refers to the order in which individual pieces of code (like functions, callbacks, or events) are executed. Due to its asynchronous, event-driven nature, control flow in Node.js can be more complex compared to traditional, linear programming languages. Here's a brief overview:\n\nAsynchronous Execution: Many operations in Node.js, particularly I/O tasks, are performed asynchronously. This means the program can continue executing other code while waiting for these operations to complete, rather than blocking the execution thread.\nEvent Loop: The heart of control flow in Node.js is the event loop. It allows Node.js to perform non-blocking I/O operations by offloading operations to the system kernel whenever possible.\nCallbacks: Control flow is often managed through callbacks. A callback function is executed after the completion of an asynchronous operation, allowing the program to continue where it left off.\nPromises and Async/Await: To manage control flow more effectively and avoid \"callback hell,\" Node.js supports Promises and the async/await syntax, making asynchronous code easier to write and understand.\nModules and Middleware: In Node.js, modularization and the use of middleware (especially in web frameworks like Express) also play a significant role in controlling the flow of applications.",
      "isPremium": false
    },
    {
      "id": 29,
      "level": "Mid",
      "title": "What is typically the first argument passed to a Node.js callback handler",
      "answer": "In Node.js, the first argument passed to a callback handler is typically an error object. This follows the error-first callback pattern, which is a standard convention in Node.js for handling asynchronous operations.\nExample:\n\njavascript\n\nCopy code\n\nfs.readFile('/path/to/file', (err, data) => {\n    if (err) {\n        console.error('Error reading file:', err);\n        return;\n    }\n    console.log('File data:', data);\n});",
      "isPremium": false
    },
    {
      "id": 30,
      "level": "Mid",
      "title": "What is the difference between Asynchronous and Non-blocking?",
      "answer": "Asynchronous operations in Node.js are executed separately from the main program flow, allowing the program to continue running while waiting for the operation to complete, typically handled with callbacks, promises, or async/await.\nNon-blocking refers to the system's ability to continue processing other tasks without waiting for an operation, like I/O, to finish, thus avoiding halting the execution. While related, asynchronous is more about the timing of operations, and non-blocking is about the system's responsiveness to resource availability.",
      "isPremium": false
    },
    {
      "id": 31,
      "level": "Mid",
      "title": "What do you understand by a test pyramid?",
      "answer": "The test pyramid is a concept in software testing that emphasizes having a large number of quick and isolated unit tests at the base, a moderate number of integration tests in the middle, and a small number of comprehensive end-to-end tests at the top.\nThis structure promotes a balanced and efficient testing strategy, where most issues are caught by fast-running unit tests, while integration and end-to-end tests ensure overall system integrity and user experience.",
      "isPremium": false
    },
    {
      "id": 32,
      "level": "Mid",
      "title": "What is ESLint?",
      "answer": "ESLint is a static code analysis tool for JavaScript and TypeScript that identifies and fixes problematic code patterns and ensures adherence to style guidelines.\nIt offers customizable rules, automated code fixing, and can be integrated into development workflows. ESLint is widely used to maintain code quality and consistency in projects.",
      "isPremium": false
    },
    {
      "id": 33,
      "level": "Mid",
      "title": "What is meant by tracing in Node.js?",
      "answer": "In Node.js, tracing refers to the process of capturing and recording diagnostic information about the execution of a program. Tracing is commonly used for performance analysis, debugging, and profiling of Node.js applications. It involves collecting data such as function calls, execution times, memory usage, and more to gain insights into how the application behaves.",
      "isPremium": false
    },
    {
      "id": 34,
      "level": "Mid",
      "title": "What is the use of module.exports in Node.js?",
      "answer": "In Node.js, module.exports is used to export functions, objects, or values from a module so they can be required and used in other modules. This mechanism allows for the modularization of code, enabling the separation of concerns and reuse of code across different parts of an application.",
      "isPremium": false
    },
    {
      "id": 35,
      "level": "Mid",
      "title": "What is the purpose of the fs module?",
      "answer": "The fs module in Node.js stands for \"File System\" and provides a set of methods and functionalities for interacting with the file system of a computer. It allows you to perform various operations on files and directories, including:\nFile I/O: Reading and writing files asynchronously or synchronously.\nFile and Directory Manipulation: Creating, deleting, renaming, and moving files and directories.\nFile Metadata: Accessing file information such as size, modification timestamps, and permissions.\nDirectory Traversal: Navigating and listing the contents of directories.\nFile Watching: Monitoring files and directories for changes.\nError Handling: Managing errors that may occur during file system operations.",
      "isPremium": false
    },
    {
      "id": 36,
      "level": "Mid",
      "title": "How to write to files in Node.js?",
      "answer": "In Node.js, you can write to files using the fs (File System) module. Here's a basic example of how to write to a file asynchronously:\n\njavascript\n\nCopy code\n\nconst fs = require('fs');\n \n// Data to write to the file\nconst dataToWrite = 'This is the content that will be written to the file.';\n \n// Specify the file path\nconst filePath = 'example.txt';\n \n// Write to the file asynchronously\nfs.writeFile(filePath, dataToWrite, (err) => {\n  if (err) {\n    console.error('Error writing to the file:', err);\n  } else {\n    console.log('File has been written successfully.');\n  }\n});",
      "isPremium": false
    },
    {
      "id": 37,
      "level": "Mid",
      "title": "What are stubs in Node.js?",
      "answer": "In Node.js, stubs are simplified, controllable replacements for complex or external functionalities used in unit testing. They simulate the behavior of real components by providing predefined responses to function calls. Stubs help isolate the code being tested from its dependencies, making tests simpler and more focused.\nThey are commonly used to test how code interacts with external systems or to simulate error conditions, often in conjunction with testing frameworks like Sinon.js.",
      "isPremium": false
    },
    {
      "id": 38,
      "level": "Mid",
      "title": "What are global objects in Node.js?",
      "answer": "Global objects in Node.js are objects that are available globally throughout the entire Node.js application without the need for explicit declaration. They can be accessed from any module without importing them. Some common global objects in Node.js include:\nconsole: Used for logging messages and data to the console.\nprocess: Provides information and control over the current Node.js process.\nBuffer: Represents binary data and is used for working with binary streams.\nrequire(): Used to import modules and their functionality.\n__dirname: Represents the directory name of the current module.\n__filename: Represents the file name of the current module.\nglobal: The global namespace object, but it's generally recommended to avoid adding properties to it.",
      "isPremium": false
    },
    {
      "id": 39,
      "level": "Mid",
      "title": "How is middleware used in Node.js?",
      "answer": "In Node.js, particularly with frameworks like Express, middleware refers to functions that have access to the request and response objects, and the next middleware function in the application’s request-response cycle. The primary uses of middleware include:\n\nRequest Processing: Middleware functions can execute any code, modify request and response objects, and end the request-response cycle.\nRoute Handling: They can be used to perform validations, parse the request body, handle cookies or sessions, etc., before the request reaches its intended route handler.\nError Handling: Middleware functions are used for error handling across the application.\nEnhancing Functionality: They can add new functionality to the application, like logging, setting security headers, or enabling CORS.\nModularizing Code: Middleware helps in breaking the application into smaller, more manageable parts, enhancing code organization and maintenance.",
      "isPremium": false
    },
    {
      "id": 40,
      "level": "Senior",
      "title": "Briefly explain how the V8 engine relates to Node.js",
      "answer": "The V8 engine, developed by Google for the Chrome browser, is a crucial component of Node.js. It compiles JavaScript into native machine code, enabling efficient and fast execution. Node.js uses the V8 engine to run JavaScript code outside the browser, allowing Node.js applications to benefit from V8's performance and optimizations.\nThis relationship allows Node.js to provide a server-side environment where JavaScript can be executed with the speed and efficiency comparable to traditional server-side languages.",
      "isPremium": false
    },
    {
      "id": 41,
      "level": "Senior",
      "title": "What are streams in Node.js?",
      "answer": "Streams in Node.js are used for handling data flow, allowing you to read or write data in chunks without loading everything into memory. They are efficient for processing large data sets and come in different types: Readable (for reading data), Writable (for writing data), Duplex (both reading and writing), and Transform (modifying data as it's read or written).\nExample of a Readable Stream:\n\njavascript\n\nCopy code\n\nconst fs = require('fs');\n \n// Create a readable stream to read a file\nconst readableStream = fs.createReadStream('example.txt');\n \nreadableStream.on('data', (chunk) => {\n  console.log(`Received ${chunk.length} bytes of data.`);\n});\n \nreadableStream.on('end', () => {\n  console.log('Finished reading file.');\n});\n\nThis code creates a readable stream for a file named example.txt, reading it in chunks and logging the size of each chunk to the console. When the file is fully read, it logs that the reading is finished.",
      "isPremium": false
    },
    {
      "id": 42,
      "level": "Senior",
      "title": "What is the difference between fork() and spawn() methods in Node.js?",
      "answer": "fork() is used for spawning new Node.js processes and establishes an IPC channel for communication between the parent and child processes. It's ideal for when you need to execute Node.js modules separately but with communication.\nExample: Let's say you have a Node.js module child.js that you want to run as a child process:\n\njavascript\n\nCopy code\n\nprocess.on('message', (msg) => {\n  console.log('Message from parent:', msg);\n});\n \nlet counter = 0;\n \nsetInterval(() => {\n  process.send({ counter: counter++ });\n}, 1000);\nYou can create a parent script that uses fork() to spawn this child process:\nspawn() is more general and can be used for any command, not limited to Node.js. It's suitable for executing system commands and handles large amounts of data output, offering a stream interface but without establishing an IPC channel by default.\nExample: For instance, listing files in a directory:\n\njavascript\n\nCopy code\n\nconst { spawn } = require('child_process');\n \nconst ls = spawn('ls', ['-lh', '/usr']);\n \nls.stdout.on('data', (data) => {\n  console.log(`Output: ${data}`);\n});\n \nls.stderr.on('data', (data) => {\n  console.error(`Error: ${data}`);\n});\n \nls.on('close', (code) => {\n  console.log(`Child process exited with code ${code}`);\n});\nHere, spawn() is used to run the ls command to list files in /usr. The output is captured via streams, allowing the parent process to handle the data as it's generated.",
      "isPremium": false
    },
    {
      "id": 43,
      "level": "Senior",
      "title": "What is the Buffer class in Node.js?",
      "answer": "The Buffer class in Node.js is used for handling raw binary data. It allows you to work with bytes of data directly, which is useful when dealing with I/O operations like file handling and network communication.\nExample:\n\njavascript\n\nCopy code\n\n// Create a Buffer containing \"Hello\"\nconst buf = Buffer.from('Hello', 'utf8');\n \n// Log the Buffer and its string equivalent\nconsole.log(buf);  // Outputs: <Buffer 48 65 6c 6c 6f>\nconsole.log(buf.toString()); // Outputs: Hello\nIn this example, a Buffer is created from a string \"Hello\" and then displayed both as raw binary data and as a human-readable string.",
      "isPremium": false
    },
    {
      "id": 44,
      "level": "Senior",
      "title": "What is piping in Node.js?",
      "answer": "Piping in Node.js is a technique used to take the output stream of one object and connect it to the input stream of another. It's a way to efficiently pass data from one source to another without intermediate holding of the data in a buffer.\nThis method is commonly used in working with streams, allowing for easy data transfer and transformation.\nExample:\n\njavascript\n\nCopy code\n\nconst fs = require('fs');\n \n// Create a readable stream to read from a file\nlet readableStream = fs.createReadStream('input.txt');\n \n// Create a writable stream to write to a file\nlet writableStream = fs.createWriteStream('output.txt');\n \n// Pipe the read and write operations\nreadableStream.pipe(writableStream);\n \nconsole.log(\"Piping is done.\");\nIn this example, the content of input.txt is piped to output.txt. This means that as soon as some data is read from input.txt, it is immediately written to output.txt, efficiently handling the data transfer.",
      "isPremium": false
    },
    {
      "id": 45,
      "level": "Senior",
      "title": "How does Node.js handle the child threads?",
      "answer": "Node.js primarily operates in a single-threaded manner, but it can handle child threads for certain operations, allowing for concurrent execution. Here's how Node.js manages child threads:\n\nLibuv Library: Node.js uses the libuv library, which provides a multi-threaded environment in the background. While the main JavaScript code runs on a single thread (the event loop), libuv handles tasks like file I/O and network communication in a multi-threaded way.\nWorker Threads: Introduced in Node.js as an experimental feature and later stabilized, Worker Threads allow running JavaScript in parallel threads. This feature can be used for CPU-intensive tasks without blocking the main event loop.\nChild Process Module: Node.js has a built-in child_process module, which can be used to create and manage child processes. This module provides functions like spawn, exec, execFile, and fork to run secondary processes. While these are not threads in the traditional sense, they allow Node.js to perform multiple tasks concurrently.\nCluster Module: For handling HTTP server load, the cluster module can be used. It enables the creation of child processes that all run their own event loop and share the server port.",
      "isPremium": false
    },
    {
      "id": 46,
      "level": "Senior",
      "title": "How does Node.js support multi-processor platforms, and does it fully utilize all processor resources?",
      "answer": "Node.js, inherently single-threaded, doesn't automatically utilize multiple processor cores. However, it can be made to support multi-processor platforms and utilize all available processor resources through specific methods:\nCluster Module: Node.js includes a cluster module that allows you to create child processes (workers) that run simultaneously and share the same server port. This module forks the main Node.js process, creating a master-worker architecture. Each worker runs in its own process and utilizes a CPU core, thus enabling the application to take advantage of multi-core systems.\nWorker Threads: Introduced in later versions of Node.js, worker threads allow running tasks in parallel threads within the same process. This feature is suitable for performing CPU-intensive tasks without blocking the main thread.\nLoad Balancing: The cluster module can also be used to implement a load balancing strategy over multiple CPU cores, distributing incoming network requests among multiple instances of the Node.js application.",
      "isPremium": false
    },
    {
      "id": 47,
      "level": "Senior",
      "title": "Explain libuv.",
      "answer": "Libuv is a cross-platform C library that provides the core asynchronous I/O functionality for Node.js. It implements an event loop and a non-blocking I/O model, enabling efficient handling of various operations like file system tasks, network communication, and timers.\nLibuv abstracts platform-specific details, ensuring consistent behavior across different operating systems. Its design contributes to Node.js's ability to handle high levels of concurrency and performance, particularly in network and I/O-driven applications.",
      "isPremium": false
    },
    {
      "id": 48,
      "level": "Senior",
      "title": "Explain the concept of Punycode in Node.js?",
      "answer": "Punycode is a character encoding scheme used in Node.js and other programming environments to convert Unicode (internationalized) domain names to ASCII (American Standard Code for Information Interchange) domain names.\nThis conversion is necessary because the Domain Name System (DNS) originally only supported ASCII characters, which limited the use of non-Latin characters in domain names.",
      "isPremium": false
    },
    {
      "id": 49,
      "level": "Senior",
      "title": "Name some security implementations within Node.js?",
      "answer": "Node.js, like any other server-side platform, requires specific security implementations to protect applications from various threats. Some common security implementations in Node.js include:\nInput Validation: Sanitize and validate user input to prevent injection attacks, like SQL Injection or Cross-Site Scripting (XSS).\nAuthentication and Authorization: Implement robust authentication mechanisms and role-based access control (RBAC) to ensure only authorized users can access specific resources.\nHTTPS: Use HTTPS to encrypt data in transit, securing communication between clients and the server.\nHelmet.js: Employ the Helmet.js library to set various security-related HTTP headers, mitigating common web vulnerabilities like Cross-Site Scripting (XSS) and Clickjacking.\nOWASP Top Ten: Follow the OWASP Top Ten Project guidelines to address common security risks such as injection attacks, broken authentication, and security misconfigurations.\nContent Security Policy (CSP): Implement CSP headers to prevent the execution of malicious scripts, protecting against XSS attacks.\nRate Limiting: Apply rate limiting to limit the number of requests from a single IP address to prevent abuse or DoS attacks.",
      "isPremium": false
    },
    {
      "id": 50,
      "level": "Senior",
      "title": "Is it possible to run external processes with Node.js?",
      "answer": "Yes, it is possible to run external processes with Node.js using the child_process module. The child_process module provides methods for spawning and interacting with child processes, which can be any external command or script executable on your system.\nExample:\n\njavascript\n\nCopy code\n\nconst { exec } = require('child_process');\n \n// Run the \"ls -l\" command in the shell\nexec('ls -l', (error, stdout, stderr) => {\n  if (error) {\n    console.error(`Error: ${error.message}`);\n    return;\n  }\n  console.log(`stdout: ${stdout}`);\n  console.error(`stderr: ${stderr}`);\n});\nIn this example, we use exec() to run the \"ls -l\" command, which lists the files in the current directory with detailed information. The output is captured and displayed in the stdout and stderr streams, and any errors are handled in the callback function.",
      "isPremium": false
    }
  ]
}