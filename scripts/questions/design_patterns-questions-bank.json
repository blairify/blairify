{
  "totalQuestions": 50,
  "extractedAt": "2025-12-19T18:03:35.827Z",
  "questions": [
    {
      "id": 1,
      "level": "Junior",
      "title": "What are design patterns?",
      "answer": "Design patterns are reusable solutions to common problems that occur during software design and development. They provide proven templates for solving recurring design challenges and promote maintainability, scalability, and code readability. Using design patterns helps ensure that software is robust, efficient, and follows established best practices.",
      "isPremium": false
    },
    {
      "id": 2,
      "level": "Junior",
      "title": "What is the difference between design patterns and design principles?",
      "answer": "Design patterns are specific, reusable solutions to common problems in software design, like the Singleton or Observer patterns. They provide a standard approach to solving known issues in software architecture and coding.\nDesign principles, on the other hand, are broad guidelines for writing better software. They are abstract, high-level concepts, such as the SOLID principles, that guide overall software design and development philosophy.",
      "isPremium": false
    },
    {
      "id": 3,
      "level": "Junior",
      "title": "What is the difference between design patterns and algorithms?",
      "answer": "Design patterns are standard solutions to common problems in software design, providing a template for how to structure or solve certain issues in coding and architecture. They are about how classes and objects are structured and interact.\nAlgorithms, on the other hand, are step-by-step procedures for calculations, data processing, and automated reasoning. They focus on the logic for solving specific computational problems.",
      "isPremium": false
    },
    {
      "id": 4,
      "level": "Junior",
      "title": "What Is Gang of Four (GOF) in Design Patterns?",
      "answer": "The \"Gang of Four\" (GoF) refers to authors Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides, who wrote the seminal book \"Design Patterns: Elements of Reusable Object-Oriented Software\" in 1994. This book categorizes 23 classic software design patterns into three types:\nCreational Patterns: Focus on object creation methods, improving flexibility in object creation. Examples: Singleton, Factory, Builder.\nStructural Patterns: Deal with object composition, ensuring larger structures are flexible and efficient. Examples: Adapter, Decorator, Proxy.\nBehavioral Patterns: Concerned with object interaction and responsibility assignment. Examples: Observer, Strategy, Command.",
      "isPremium": false
    },
    {
      "id": 5,
      "level": "Junior",
      "title": "What is Inversion of Control?",
      "answer": "Inversion of Control (IoC) is a programming principle that reverses the flow of control in software, shifting it from the programmer to the framework or runtime. This leads to better decoupling of components and enhances flexibility, testability, and configurability of the software. The most common methods to implement IoC are:\nDependency Injection (DI): Dependencies are supplied to components by an external source rather than created within the components themselves.\nEvent-driven Programming: The program flow is controlled by events such as user actions or sensor inputs.\nService Locator Pattern: Components retrieve their dependencies from a central registry.",
      "isPremium": false
    },
    {
      "id": 6,
      "level": "Junior",
      "title": "Name the three main categories into which design patterns can be classified?",
      "answer": "Creational Patterns: These patterns are all about class instantiation or object creation. They abstract the process of instantiation. They help make a system independent of how its objects are created, composed, and represented. Examples include Singleton, Factory, Abstract Factory, Builder, and Prototype.\nStructural Patterns: These patterns are about organizing different classes and objects to form larger structures and provide new functionality. They help in building efficient and scalable systems. Examples include Adapter, Bridge, Composite, Decorator, Facade, Flyweight, and Proxy.\nBehavioral Patterns: These patterns are about identifying common communication patterns between objects and realizing these patterns. By doing this, these patterns increase flexibility in carrying out communication. Examples include Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, and Visitor.",
      "isPremium": false
    },
    {
      "id": 7,
      "level": "Junior",
      "title": "Can you name some of the creational design patterns?",
      "answer": "Creational design patterns in software engineering focus on ways to create objects, emphasizing flexibility and reusability in the instantiation process. They help in abstracting the instantiation process and managing object creation, reducing the dependence on specific classes.\nExamples:\nSingleton: Ensures only one instance of a class exists and provides a global point of access to it.\nFactory Method: Defines an interface for creating an object, but lets subclasses decide which class to instantiate.\nAbstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.\nBuilder: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations.\nPrototype: Creates new objects by copying an existing object, known as the prototype.",
      "isPremium": false
    },
    {
      "id": 8,
      "level": "Junior",
      "title": "Explain the Singleton design pattern.",
      "answer": "The Singleton design pattern is a creational pattern that ensures a class has only one instance and provides a global point of access to that instance. It's commonly used when exactly one object is needed to coordinate actions across the system.\nKey components:\nPrivate constructor: Prevents other classes from instantiating a new object directly.\nPrivate static variable: Holds the single instance of the class.\nPublic static method: Often called getInstance(), this method provides the global access point to the instance and ensures that only one instance is created.",
      "isPremium": false
    },
    {
      "id": 9,
      "level": "Junior",
      "title": "Give an example of the Singleton design pattern.",
      "answer": "Database Connection: A database connection is a resource-intensive operation. Using the Singleton pattern can ensure that only one connection is open at a time. The single instance can be used to execute queries throughout the application, avoiding the overhead of opening and closing multiple connections.\n\njava\n\nCopy code\n\npublic class DatabaseConnection {\n    // The single instance of the class\n    private static DatabaseConnection instance;\n \n    // Private constructor\n    private DatabaseConnection() {\n        // initialize connection\n    }\n \n    // Public method to get the instance\n    public static DatabaseConnection getInstance() {\n        if (instance == null) {\n            instance = new DatabaseConnection();\n        }\n        return instance;\n    }\n \n    // Method to use the connection\n    public void executeQuery(String query) {\n        // execute database query\n    }\n}\n \n// Usage\nDatabaseConnection dbConnection = DatabaseConnection.getInstance();\ndbConnection.executeQuery(\"SELECT * FROM users\");\nIn this example, DatabaseConnection class ensures there is only one database connection open at any time. Any attempt to instantiate DatabaseConnection will be directed to the existing instance, promoting efficient resource usage.",
      "isPremium": false
    },
    {
      "id": 10,
      "level": "Junior",
      "title": "Explain the Factory Method.",
      "answer": "The Factory Method design pattern is a creational pattern that defines an interface for creating an object but lets subclasses decide which class to instantiate. It's used to delegate the responsibility of instantiating objects to subclasses, allowing for flexibility and encapsulation in object creation.\nKey Components:\nSuperclass: Defines an abstract method for creating objects.\nSubclasses: Implement the abstract method to create specific objects.",
      "isPremium": false
    },
    {
      "id": 11,
      "level": "Junior",
      "title": "Give an example of the Factory Method design pattern.",
      "answer": "UI Components: In a UI framework, a ButtonFactory superclass can define a method createButton(). Subclasses like WindowsButtonFactory and MacButtonFactory can implement this method to return WindowsButton and MacButton objects, respectively.\n\njava\n\nCopy code\n\nabstract class ButtonFactory {\n    public abstract Button createButton();\n}\n \nclass WindowsButtonFactory extends ButtonFactory {\n    @Override\n    public Button createButton() {\n        return new WindowsButton();\n    }\n}\n \nclass MacButtonFactory extends ButtonFactory {\n    @Override\n    public Button createButton() {\n        return new MacButton();\n    }\n}\n \ninterface Button {\n    void render();\n}\n \nclass WindowsButton implements Button {\n    @Override\n    public void render() {\n        System.out.println(\"Windows button rendered\");\n    }\n}\n \nclass MacButton implements Button {\n    @Override\n    public void render() {\n        System.out.println(\"Mac button rendered\");\n    }\n}\n \n// Usage\nButtonFactory factory = new WindowsButtonFactory();\nButton button = factory.createButton();\nbutton.render(); // Output: Windows button rendered\nIn this example, ButtonFactory is the superclass with the abstract method createButton(). The WindowsButtonFactory and MacButtonFactory subclasses implement this method to instantiate WindowsButton and MacButton, demonstrating how Factory Method encapsulates object creation.",
      "isPremium": false
    },
    {
      "id": 12,
      "level": "Junior",
      "title": "Explain the Abstract Factory Method design pattern.",
      "answer": "The Abstract Factory Method design pattern is a creational pattern that provides an interface for creating families of related or dependent objects without specifying their concrete classes. It involves multiple factory methods, one for each type of object to be created.\nThe key idea is to abstract the creation of objects that belong to a related \"family\" and let the subclasses of the abstract factory decide which objects to instantiate.\nKey Components:\nAbstract Factory: An interface with methods for creating abstract products.\nConcrete Factories: Implement the abstract factory methods to create concrete products.\nAbstract Products: Define a product interface.\nConcrete Products: Implement the product interface and define the product to be created.",
      "isPremium": false
    },
    {
      "id": 13,
      "level": "Junior",
      "title": "Give an example of the Abstract Factory Method design pattern.",
      "answer": "Cross-Platform UI Elements: An application that needs to work on multiple operating systems (Windows, MacOS, Linux) and requires different styles of UI elements (buttons, checkboxes) for each platform.\n\njava\n\nCopy code\n\n// Abstract Factory\ninterface GUIFactory {\n    Button createButton();\n    Checkbox createCheckbox();\n}\n \n// Concrete Factories\nclass WindowsFactory implements GUIFactory {\n    public Button createButton() { /* Windows-specific button */ }\n    public Checkbox createCheckbox() { /* Windows-specific checkbox */ }\n}\n \nclass MacOSFactory implements GUIFactory {\n    public Button createButton() { /* MacOS-specific button */ }\n    public Checkbox createCheckbox() { /* MacOS-specific checkbox */ }\n}\n \n// Abstract Products\ninterface Button { /* Button interface */ }\ninterface Checkbox { /* Checkbox interface */ }\n \n// Concrete Products\nclass WindowsButton implements Button { /* Implementation */ }\nclass MacOSButton implements Button { /* Implementation */ }\n// Same for Checkbox\n \n// Usage\nGUIFactory factory = new WindowsFactory();\nButton button = factory.createButton();\nCheckbox checkbox = factory.createCheckbox();\nIn this example, GUIFactory is the abstract factory with methods to create Button and Checkbox. WinFactory and MacFactory are concrete factories that produce Windows and Mac style UI elements, respectively. This pattern allows the creation of platform-specific UI elements while keeping the client code abstracted from the specific classes that need to be instantiated.",
      "isPremium": false
    },
    {
      "id": 14,
      "level": "Junior",
      "title": "Explain the Builder design pattern.",
      "answer": "The Builder design pattern is a creational pattern that separates the construction of a complex object from its representation, allowing the same construction process to create different representations. This pattern is particularly useful when an object needs to be created with many optional components or configurations.\nKey Components:\nBuilder: An abstract interface that specifies methods for creating different parts of a product.\nConcrete Builder: Implements the Builder interface to construct and assemble parts of the product, defining and keeping track of the representation it creates.\nDirector: Optionally defines the order in which to call construction steps, so you can create and reuse specific configurations of products.\nProduct: The final object that is created by the Concrete Builder.",
      "isPremium": false
    },
    {
      "id": 15,
      "level": "Junior",
      "title": "Give an example of the Builder design pattern.",
      "answer": "Creating a Custom Pizza: A pizza ordering system where a customer can choose various aspects (crust, toppings, size).\n\njava\n\nCopy code\n\n// Builder\ninterface PizzaBuilder {\n    void buildDough();\n    void buildSauce();\n    void buildTopping();\n}\n \n// Concrete Builder\nclass MargheritaPizzaBuilder implements PizzaBuilder {\n    Pizza pizza = new Pizza();\n    public void buildDough() { pizza.setDough(\"Thin Crust\"); }\n    public void buildSauce() { pizza.setSauce(\"Tomato\"); }\n    public void buildTopping() { pizza.setTopping(\"Cheese\"); }\n    Pizza getPizza() { return pizza; }\n}\n \n// Product\nclass Pizza {\n    // Pizza properties and methods\n}\n \n// Usage\nPizzaBuilder builder = new MargheritaPizzaBuilder();\nbuilder.buildDough();\nbuilder.buildSauce();\nbuilder.buildTopping();\nPizza pizza = builder.getPizza();\nIn this example, PizzaBuilder is the Builder interface, MargheritaPizzaBuilder is a Concrete Builder, and Pizza is the Product. The Builder pattern allows for different representations of pizza to be constructed using the same process.",
      "isPremium": false
    },
    {
      "id": 16,
      "level": "Mid",
      "title": "Explain the Prototype design pattern.",
      "answer": "The Prototype design pattern is a creational pattern that involves creating new objects by copying an existing object, known as the prototype. This pattern is used when the cost of creating an object is more expensive or complex than copying an existing object. It's particularly useful when dealing with objects where the variations in properties are minimal.\nKey Components:\nPrototype: An interface that defines the cloning method.\nConcrete Prototype: Implements the cloning method to create a duplicate of itself.\nClient: Creates new objects by asking a prototype to clone itself.",
      "isPremium": false
    },
    {
      "id": 17,
      "level": "Mid",
      "title": "Give an example of the Prototype design pattern.",
      "answer": "Graphic Objects in a Drawing Application: A drawing application can use prototypes of different shapes (like circles, rectangles) that can be cloned and customized as needed.\n\njava\n\nCopy code\n\n// Prototype\ninterface Graphic {\n    Graphic clone();\n}\n \n// Concrete Prototype\nclass Circle implements Graphic {\n    int radius;\n \n    Circle(int radius) { this.radius = radius; }\n \n    // Copy constructor for cloning\n    Circle(Circle circle) { this.radius = circle.radius; }\n \n    @Override\n    public Graphic clone() {\n        return new Circle(this);\n    }\n}\n \n// Usage\nGraphic circlePrototype = new Circle(10);\nGraphic clonedCircle = circlePrototype.clone();\nIn this example, Graphic is the Prototype interface, and Circle is the Concrete Prototype. The clone method in Circle creates a copy of the Circle instance, demonstrating how new objects can be created through cloning rather than direct construction.",
      "isPremium": false
    },
    {
      "id": 18,
      "level": "Mid",
      "title": "What are structural design patterns, and can you name a few?",
      "answer": "Structural design patterns are concerned with how classes and objects are composed to form larger structures. They help ensure that when one part of a system changes, the entire structure does not need to change.\nThese patterns focus on simplifying the design by identifying a simple way to realize relationships between entities.\nExamples:\nAdapter Pattern: Allows incompatible interfaces to work together. It involves a wrapper that converts one interface to another.\nBridge Pattern: Separates an abstraction from its implementation so that the two can vary independently.\nComposite Pattern: Composes objects into tree structures to represent part-whole hierarchies, allowing clients to treat individual objects and compositions uniformly.\nDecorator Pattern: Adds new functionality to an object dynamically, without altering its structure. This is achieved by creating a decorator class that wraps the original class.\nFacade Pattern: Provides a simplified interface to a complex subsystem, thereby reducing the learning curve and minimizing dependencies on external code.\nFlyweight Pattern: Reduces the cost of creating and manipulating a large number of similar objects.\nProxy Pattern: Provides a placeholder for another object to control access to it, either for delaying its instantiation, improving performance, or adding security layers.",
      "isPremium": false
    },
    {
      "id": 19,
      "level": "Mid",
      "title": "Explain the Adapter design pattern.",
      "answer": "The Adapter design pattern, a structural pattern, is used to enable incompatible interfaces to work together. It acts as a bridge between two incompatible interfaces by wrapping the interface of one class into another interface clients expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.\nKey Components:\nTarget: The interface that the client expects or uses.\nAdapter: Adapts the interface of the Adaptee to the Target interface.\nAdaptee: The interface that needs adapting.\nClient: Uses the Target interface.",
      "isPremium": false
    },
    {
      "id": 20,
      "level": "Mid",
      "title": "Give an example of the Adapter design pattern.",
      "answer": "Power Socket Compatibility: A power adapter that enables a device with a two-pin plug (Adaptee) to be used in a three-pin socket (Target).\n\njava\n\nCopy code\n\n// Target\ninterface ThreePinSocket {\n    void plugInThreePinDevice();\n}\n \n// Adaptee\nclass TwoPinPlug {\n    void plugInTwoPinDevice() {\n        System.out.println(\"Two-pin device plugged in.\");\n    }\n}\n \n// Adapter\nclass SocketAdapter implements ThreePinSocket {\n    private TwoPinPlug twoPinPlug;\n \n    public SocketAdapter(TwoPinPlug twoPinPlug) {\n        this.twoPinPlug = twoPinPlug;\n    }\n \n    @Override\n    public void plugInThreePinDevice() {\n        twoPinPlug.plugInTwoPinDevice();\n    }\n}\n \n// Usage\nTwoPinPlug twoPinPlug = new TwoPinPlug();\nThreePinSocket adapter = new SocketAdapter(twoPinPlug);\nadapter.plugInThreePinDevice(); // Output: Two-pin device plugged in.\nIn this example, ThreePinSocket is the Target interface, TwoPinPlug is the Adaptee, and SocketAdapter is the Adapter. The Adapter pattern allows a two-pin plug to be used in a three-pin socket, demonstrating the ability to make incompatible interfaces compatible.",
      "isPremium": false
    },
    {
      "id": 21,
      "level": "Mid",
      "title": "Explain the Bridge design pattern.",
      "answer": "The Bridge design pattern is a structural pattern that separates an abstraction from its implementation, allowing both to vary independently. This pattern involves an abstraction that holds a reference to an implementer, but the implementer's interface does not have to match the abstraction's interface.\nKey Components:\nAbstraction: Defines a high-level interface and holds a reference to an implementer (Implementor).\nImplementor: Defines the interface for implementation classes.\nConcrete Implementor: Provides specific implementations of the Implementor's interface.\nRefined Abstraction: Extends the Abstraction, providing more specific logic.",
      "isPremium": false
    },
    {
      "id": 22,
      "level": "Mid",
      "title": "Give an example of the Bridge design pattern.",
      "answer": "Different Types of Remotes Controlling Different Devices: A TV and a Radio, each can be controlled by different types of remote controls (like a regular remote or a smart remote). The Bridge pattern allows different remotes to work with different devices, mixing and matching as needed.\n\njava\n\nCopy code\n\n// Implementor\ninterface Device {\n    void turnOn();\n    void turnOff();\n}\n \n// Concrete Implementors\nclass TV implements Device {\n    // Implementation details\n}\n \nclass Radio implements Device {\n    // Implementation details\n}\n \n// Abstraction\nabstract class RemoteControl {\n    protected Device device;\n    abstract void togglePower();\n}\n \n// Refined Abstraction\nclass BasicRemote extends RemoteControl {\n    // Implementation details\n}\n \n// Usage\nDevice tv = new TV();\nRemoteControl remote = new BasicRemote(tv);\nremote.togglePower();\nIn this example, Device is the Implementor, TV and Radio are Concrete Implementors, RemoteControl is the Abstraction, and BasicRemote is a Refined Abstraction. The Bridge pattern allows RemoteControl to use any Device independently, demonstrating its capability to separate abstraction from implementation.",
      "isPremium": false
    },
    {
      "id": 23,
      "level": "Mid",
      "title": "Explain the Composite design pattern.",
      "answer": "The Composite design pattern is a structural pattern that allows for the composition of objects into tree-like structures to represent part-whole hierarchies. It enables clients to treat individual objects and compositions of objects uniformly.\nKey Components:\nComponent: An interface or abstract class defining operations for both simple and complex objects.\nLeaf: Represents individual objects in the structure without children.\nComposite: A group of leaf objects or other composites. It can perform operations on its children.",
      "isPremium": false
    },
    {
      "id": 24,
      "level": "Mid",
      "title": "Give an example of the Composite design pattern.",
      "answer": "Graphic Drawing Application: Used to represent and manipulate individual shapes or groups of shapes (like circles, rectangles) in a uniform manner.\n\njava\n\nCopy code\n\n// Component\ninterface Graphic {\n    void draw();\n    // other methods like add, remove, getChild\n}\n \n// Leaf\nclass Circle implements Graphic {\n    public void draw() {\n        System.out.println(\"Circle drawn\");\n    }\n    // other methods with no meaningful implementation\n}\n \n// Composite\nclass CompositeGraphic implements Graphic {\n    // Contains leaf elements and implements the operations\n}\n \n// Usage\nCompositeGraphic graphicGroup = new CompositeGraphic();\ngraphicGroup.add(new Circle());\ngraphicGroup.draw(); // Draws all elements in the composite\nIn this example, Circle (Leaf) and CompositeGraphic (Composite) both implement the Graphic interface, allowing the client to interact with both simple (Leaf) and complex (Composite) objects uniformly. The Composite pattern is beneficial for scenarios where clients need to work with hierarchies of objects.",
      "isPremium": false
    },
    {
      "id": 25,
      "level": "Mid",
      "title": "Explain the Decorator design pattern.",
      "answer": "The Decorator design pattern is a structural pattern that allows behavior to be added to individual objects, dynamically, without affecting the behavior of other objects from the same class. It involves a set of decorator classes that are used to wrap concrete components.\nKey Components:\nComponent: An interface or abstract class defining the operations that can be altered by decorators.\nConcrete Component: A class implementing the Component interface.\nDecorator: An abstract class that wraps a component and implements the Component interface.\nConcrete Decorator: A class that extends the Decorator class and adds new behavior to the Component.",
      "isPremium": false
    },
    {
      "id": 26,
      "level": "Mid",
      "title": "Give an example of the Decorator design pattern.",
      "answer": "Coffee Customization: In a coffee app, various toppings and extras (like milk, sugar, chocolate) can be added to a basic coffee order.\n\njava\n\nCopy code\n\n// Component\ninterface Coffee {\n    String getDescription();\n    double getCost();\n}\n \n// Concrete Component\nclass SimpleCoffee implements Coffee {\n    // Implementation details\n}\n \n// Decorator\nabstract class CoffeeDecorator implements Coffee {\n    // Wraps a Coffee object\n}\n \n// Concrete Decorators\nclass WithMilk extends CoffeeDecorator {\n    // Adds milk behavior\n}\n \nclass WithSugar extends CoffeeDecorator {\n    // Adds sugar behavior\n}\n \n// Usage\nCoffee coffee = new WithMilk(new WithSugar(new SimpleCoffee()));\nThis pattern provides flexibility in adding or removing responsibilities from objects at runtime, making it useful for scenarios where functionality needs to be extended in a modular and maintainable manner.",
      "isPremium": false
    },
    {
      "id": 27,
      "level": "Mid",
      "title": "Explain the Proxy design pattern.",
      "answer": "The Proxy design pattern is a structural pattern that provides a surrogate or placeholder for another object to control access to it. This can be for the purpose of managing complexity, controlling the creation and access, or adding new functionalities.\nKey Components:\nSubject: An interface common to both the real object and the proxy.\nReal Subject: The real object that the proxy represents.\nProxy: Maintains a reference to the Real Subject, controls access to it, and may be responsible for its creation and deletion.",
      "isPremium": false
    },
    {
      "id": 28,
      "level": "Mid",
      "title": "Give an example of the Proxy design pattern.",
      "answer": "Lazy Initialization: A high-resolution image object that is memory-intensive. A proxy can control the creation of this object so that it is only loaded into memory when actually needed.\n\njava\n\nCopy code\n\n// Subject\ninterface Image {\n    void display();\n}\n \n// Real Subject\nclass RealImage implements Image {\n    private String filename;\n \n    public RealImage(String filename) {\n        this.filename = filename;\n        loadFromDisk(filename);\n    }\n \n    private void loadFromDisk(String filename) {\n        System.out.println(\"Loading \" + filename);\n    }\n \n    public void display() {\n        System.out.println(\"Displaying \" + filename);\n    }\n}\n \n// Proxy\nclass ProxyImage implements Image {\n    private RealImage realImage;\n    private String filename;\n \n    public ProxyImage(String filename) {\n        this.filename = filename;\n    }\n \n    public void display() {\n        if (realImage == null) {\n            realImage = new RealImage(filename);\n        }\n        realImage.display();\n    }\n}\n \n// Usage\nImage image = new ProxyImage(\"test.jpg\");\nimage.display(); // Image is loaded and displayed\nimage.display(); // Image is displayed without loading\nIn this example, Image is the Subject, RealImage is the Real Subject, and ProxyImage is the Proxy. The ProxyImage controls access to RealImage, loading the image into memory only when display is first called, demonstrating lazy initialization.",
      "isPremium": false
    },
    {
      "id": 29,
      "level": "Mid",
      "title": "What is the MVC design pattern?",
      "answer": "The MVC (Model-View-Controller) design pattern is an architectural pattern used for developing user interfaces. It divides the application into three interconnected components:\nModel: Manages the data, logic, and rules of the application.\nView: Represents the output or presentation layer (UI).\nController: Interprets user input, converting it to commands for the Model or View.",
      "isPremium": false
    },
    {
      "id": 30,
      "level": "Mid",
      "title": "Name some frameworks that implement the MVC pattern?",
      "answer": "Several frameworks implement the Model-View-Controller (MVC) pattern across different programming languages.\nRuby on Rails (Ruby): A highly popular full-stack web application framework that follows the MVC pattern.\nASP.NET MVC (C#): A web application framework developed by Microsoft, which implements the MVC pattern.\nDjango (Python): Although Django has its own unique architecture, it closely resembles the MVC pattern. It's a high-level framework that encourages rapid development and clean, pragmatic design.\nSpring MVC (Java): Part of the larger Spring Framework, Spring MVC provides a comprehensive infrastructure for developing MVC applications in Java.\nLaravel (PHP): A modern PHP framework that follows the MVC pattern, known for its elegant syntax and rich features.\nExpress.js (JavaScript, Node.js): A minimal and flexible Node.js web application framework that provides a robust set of features for web and mobile applications, often used in an MVC context.\nAngular (TypeScript): A platform and framework for building single-page client applications using HTML and TypeScript. It's structured based on components and services, but it can be adapted to fit the MVC pattern.",
      "isPremium": false
    },
    {
      "id": 31,
      "level": "Senior",
      "title": "What are behavioral design patterns, and can you name a few?",
      "answer": "Behavioral design patterns are focused on improving communication and distribution of responsibilities between objects. They help in managing complex interactions and facilitate flexible and maintainable software design.\nKey Behavioral Patterns Include:\nObserver: Manages one-to-many dependencies between objects, automatically updating dependents when one object changes.\nStrategy: Enables the selection of an algorithm at runtime, making algorithms interchangeable.\nCommand: Encapsulates a request as an object, allowing operations to be parameterized, queued, and logged.\nState: Allows objects to change behavior when their internal state changes, seemingly changing their class.\nTemplate Method: Defines the skeleton of an algorithm in a superclass, but lets subclasses override specific steps of the algorithm.\nIterator: Provides a way to sequentially access elements of a collection without exposing its underlying structure.\nMediator: Encapsulates how a set of objects interact, promoting loose coupling by preventing objects from referring to each other explicitly.\nMemento: Allows an object's state to be saved and restored, enabling undo or rollback capabilities.",
      "isPremium": false
    },
    {
      "id": 32,
      "level": "Senior",
      "title": "Explain the Observer design pattern.",
      "answer": "The Observer design pattern is a behavioral pattern that establishes a one-to-many relationship between objects. When the state of one object (the subject) changes, all its dependents (observers) are notified and updated automatically.\nThis pattern is widely used for implementing distributed event handling systems.\nKey Components:\nSubject: Maintains a list of observers and notifies them of state changes.\nObserver: An interface with a method that is called when the subject's state changes.\nConcrete Observer: Implements the Observer interface and performs some action when notified by the Subject.",
      "isPremium": false
    },
    {
      "id": 33,
      "level": "Senior",
      "title": "Give an example of the Observer design pattern.",
      "answer": "Weather Station: A weather station (Subject) broadcasts weather updates to various display elements (Observers), like a current conditions display, a statistics display, etc.\n\njava\n\nCopy code\n\n// Observer\ninterface Observer {\n    void update(float temperature, float humidity, float pressure);\n}\n \n// Subject\ninterface Subject {\n    void registerObserver(Observer o);\n    void removeObserver(Observer o);\n    void notifyObservers();\n}\n \n// Concrete Subject\nclass WeatherData implements Subject {\n    private float temperature;\n    private float humidity;\n    private float pressure;\n    private List<Observer> observers;\n \n    public WeatherData() {\n        observers = new ArrayList<>();\n    }\n \n    public void registerObserver(Observer o) { /* Add observer */ }\n    public void removeObserver(Observer o) { /* Remove observer */ }\n    public void notifyObservers() { /* Notify all observers */ }\n \n    public void measurementsChanged() {\n        notifyObservers();\n    }\n \n    public void setMeasurements(float temperature, float humidity, float pressure) {\n        // set values and call measurementsChanged\n    }\n}\n \n// Concrete Observer\nclass CurrentConditionsDisplay implements Observer {\n    public void update(float temperature, float humidity, float pressure) {\n        System.out.println(\"Current conditions: \" + temperature + \"F degrees and \" + humidity + \"% humidity\");\n    }\n}\n \n// Usage\nWeatherData weatherData = new WeatherData();\nObserver currentDisplay = new CurrentConditionsDisplay();\nweatherData.registerObserver(currentDisplay);\nweatherData.setMeasurements(80, 65, 30.4f);\nIn this example, WeatherData is the Concrete Subject, and CurrentConditionsDisplay is a Concrete Observer. When the weather data changes, it notifies CurrentConditionsDisplay, which then updates its display accordingly. This demonstrates the Observer pattern's ability to facilitate loose coupling between the Subject and its Observers.",
      "isPremium": false
    },
    {
      "id": 34,
      "level": "Senior",
      "title": "Explain the Strategy design pattern.",
      "answer": "The Strategy design pattern is a behavioral pattern that defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from the clients that use it.\nIt's useful for situations where you need to dynamically change the behavior of an object.\nKey Components:\nStrategy: An interface common to all supported algorithms.\nConcrete Strategy: Implements the algorithm defined by the Strategy interface.\nContext: Holds a reference to a Strategy instance and delegates the execution of the algorithm to the Strategy object.",
      "isPremium": false
    },
    {
      "id": 35,
      "level": "Senior",
      "title": "Give an example of the Strategy design pattern.",
      "answer": "Different Types of Sorting: An application where different types of sorting algorithms (like quicksort, mergesort, bubblesort) can be used interchangeably based on the dataset's size or nature.\n\njava\n\nCopy code\n\n// Strategy\ninterface SortingStrategy {\n    void sort(List<Integer> list);\n}\n \n// Concrete Strategies\nclass QuickSort implements SortingStrategy {\n    public void sort(List<Integer> list) {\n        // Implement quicksort here\n    }\n}\n \nclass BubbleSort implements SortingStrategy {\n    public void sort(List<Integer> list) {\n        // Implement bubblesort here\n    }\n}\n \n// Context\nclass SortedList {\n    private SortingStrategy strategy;\n \n    public void setSortingStrategy(SortingStrategy strategy) {\n        this.strategy = strategy;\n    }\n \n    public void sort(List<Integer> list) {\n        strategy.sort(list);\n    }\n}\n \n// Usage\nSortedList list = new SortedList();\nlist.setSortingStrategy(new QuickSort());\nlist.sort(new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5, 9)));\nIn this example, SortingStrategy is the Strategy interface, QuickSort and BubbleSort are Concrete Strategies, and SortedList is the Context. The Strategy pattern allows changing the sorting behavior of SortedList by switching between different sorting algorithms at runtime.",
      "isPremium": false
    },
    {
      "id": 36,
      "level": "Senior",
      "title": "Explain the Command design pattern.",
      "answer": "The Command design pattern is a behavioral pattern that turns a request into a stand-alone object containing all information about the request.\nThis transformation lets you parameterize methods with different requests, delay or queue a request's execution, and support undoable operations.\nKey Components:\nCommand: An interface that declares a method for executing a command.\nConcrete Command: Implements the Command interface and defines the binding between a Receiver object and an action.\nInvoker: Asks the Command to carry out the request.\nReceiver: Knows how to perform the operations associated with carrying out a request.\nClient: Creates a Concrete Command object and sets its receiver.",
      "isPremium": false
    },
    {
      "id": 37,
      "level": "Senior",
      "title": "Give an example of the Command design pattern.",
      "answer": "Remote Control: A universal remote control with buttons programmed to perform various commands on electronic devices like turning on the TV, changing channels, or playing music.\n\njava\n\nCopy code\n\n// Command\ninterface Command {\n    void execute();\n}\n \n// Concrete Command\nclass LightOnCommand implements Command {\n    private Light light;\n \n    public LightOnCommand(Light light) {\n        this.light = light;\n    }\n \n    public void execute() {\n        light.turnOn();\n    }\n}\n \n// Receiver\nclass Light {\n    public void turnOn() {\n        System.out.println(\"Light is on\");\n    }\n}\n \n// Invoker\nclass RemoteControl {\n    private Command command;\n \n    public void setCommand(Command command) {\n        this.command = command;\n    }\n \n    public void pressButton() {\n        command.execute();\n    }\n}\n \n// Usage\nLight light = new Light();\nCommand lightOn = new LightOnCommand(light);\nRemoteControl remote = new RemoteControl();\nremote.setCommand(lightOn);\nremote.pressButton(); // Output: Light is on\nIn this example, Command is the interface, LightOnCommand is a Concrete Command, Light is the Receiver, and RemoteControl is the Invoker. The Command pattern encapsulates a light turning on command as an object, allowing the remote control to execute different commands.",
      "isPremium": false
    },
    {
      "id": 38,
      "level": "Senior",
      "title": "Explain the State design pattern.",
      "answer": "The State design pattern is a behavioral pattern that allows an object to change its behavior when its internal state changes, appearing as if it changed its class.\nIt encapsulates state-specific behaviors within state objects, enabling an object to change its behavior dynamically.\nKey Components:\nContext: Maintains an instance of a ConcreteState subclass that defines the current state.\nState: An interface defining methods to be implemented by Concrete States, representing different states of the Context.\nConcrete States: Implement the State interface and provide the behavior associated with a state of the Context.",
      "isPremium": false
    },
    {
      "id": 39,
      "level": "Senior",
      "title": "Give an example of the State design pattern.",
      "answer": "Traffic Light: A traffic light changing its behavior based on its current state (red, green, yellow).\n\njava\n\nCopy code\n\n// State\ninterface TrafficLightState {\n    void change(TrafficLight light);\n}\n \n// Concrete States\nclass Red implements TrafficLightState {\n    public void change(TrafficLight light) {\n        System.out.println(\"Red light\");\n        light.setState(new Green());\n    }\n}\n \nclass Green implements TrafficLightState {\n    public void change(TrafficLight light) {\n        System.out.println(\"Green light\");\n        light.setState(new Yellow());\n    }\n}\n \nclass Yellow implements TrafficLightState {\n    public void change(TrafficLight light) {\n        System.out.println(\"Yellow light\");\n        light.setState(new Red());\n    }\n}\n \n// Context\nclass TrafficLight {\n    private TrafficLightState state;\n \n    public TrafficLight(TrafficLightState state) {\n        this.state = state;\n    }\n \n    public void setState(TrafficLightState state) {\n        this.state = state;\n    }\n \n    public void change() {\n        state.change(this);\n    }\n}\n \n// Usage\nTrafficLight light = new TrafficLight(new Red());\nlight.change();  // Output: Red light\nlight.change();  // Output: Green light\nlight.change();  // Output: Yellow light\nIn this example, TrafficLightState is the State interface, Red, Green, and Yellow are Concrete States, and TrafficLight is the Context. The traffic light changes its state and behavior dynamically, demonstrating how the State pattern allows an object to behave differently based on its internal state.",
      "isPremium": false
    },
    {
      "id": 40,
      "level": "Senior",
      "title": "Explain the Template Method design pattern.",
      "answer": "The Template Method design pattern is a behavioral pattern that defines the skeleton of an algorithm in a method of a superclass but lets subclasses override specific steps of the algorithm without changing its structure.\nItâ€™s particularly useful for reusing common parts of an algorithm while allowing variations in some steps.\nKey Components:\nAbstract Class: Defines abstract operations that concrete subclasses define to implement steps of an algorithm and provides a template method defining the skeleton of the algorithm.\nConcrete Class: Implements the abstract operations to carry out subclass-specific steps of the algorithm.",
      "isPremium": false
    },
    {
      "id": 41,
      "level": "Senior",
      "title": "Give an example of the Template Method design pattern.",
      "answer": "Data Processing: A data parser that provides a common structure for parsing data (like reading, processing, and saving data) but allows subclasses to define how specific data formats are parsed.\n\njava\n\nCopy code\n\n// Abstract Class\nabstract class DataParser {\n    // Template method\n    public final void parseData() {\n        readData();\n        processData();\n        writeData();\n    }\n \n    abstract void readData();\n    abstract void processData();\n    void writeData() {\n        System.out.println(\"Writing data to output.\");\n    }\n}\n \n// Concrete Class\nclass CSVDataParser extends DataParser {\n    void readData() {\n        System.out.println(\"Reading data from CSV file.\");\n    }\n \n    void processData() {\n        System.out.println(\"Processing CSV data.\");\n    }\n}\n \n// Usage\nDataParser parser = new CSVDataParser();\nparser.parseData(); // Output: Reading data from CSV file.\n                    //         Processing CSV data.\n                    //         Writing data to output.\nIn this example, DataParser is the Abstract Class with the template method parseData, and CSVDataParser is a Concrete Class implementing the specific steps (readData and processData). The Template Method pattern allows the structure of the algorithm to be maintained while letting subclasses define the actual behavior of specific steps.",
      "isPremium": false
    },
    {
      "id": 42,
      "level": "Senior",
      "title": "Explain the Iterator design pattern.",
      "answer": "The Iterator design pattern is a behavioral pattern that provides a way to access elements of an aggregate object sequentially without exposing its underlying representation. It decouples the iteration process from the aggregate object.\nKey Components:\nIterator: An interface for traversing elements.\nConcrete Iterator: Implements the Iterator interface for a specific aggregate.\nAggregate: An interface that defines the creation of an Iterator object.\nConcrete Aggregate: Implements the Aggregate interface and returns a Concrete Iterator.",
      "isPremium": false
    },
    {
      "id": 43,
      "level": "Senior",
      "title": "Give an example of the Iterator design pattern.",
      "answer": "Custom Collection: Iterating over a custom data structure, like a linked list or a tree, without exposing its internal structure.\n\njava\n\nCopy code\n\n// Iterator\ninterface Iterator {\n    boolean hasNext();\n    Object next();\n}\n \n// Aggregate\ninterface Container {\n    Iterator getIterator();\n}\n \n// Concrete Aggregate\nclass NameRepository implements Container {\n    private String[] names = {\"John\", \"Jane\", \"Jack\", \"Jill\"};\n \n    public Iterator getIterator() {\n        return new NameIterator();\n    }\n \n    private class NameIterator implements Iterator {\n        int index;\n \n        public boolean hasNext() {\n            return index < names.length;\n        }\n \n        public Object next() {\n            if (this.hasNext()) {\n                return names[index++];\n            }\n            return null;\n        }\n    }\n}\n \n// Usage\nContainer names = new NameRepository();\nfor (Iterator iter = names.getIterator(); iter.hasNext();) {\n    String name = (String)iter.next();\n    System.out.println(\"Name : \" + name);\n}\nIn this example, Iterator is the interface for traversing elements, NameRepository is the Concrete Aggregate implementing the Container interface, and NameIterator is the Concrete Iterator. The Iterator pattern enables iteration over the names array within NameRepository without exposing its underlying array structure.",
      "isPremium": false
    },
    {
      "id": 44,
      "level": "Senior",
      "title": "Explain the Mediator design pattern.",
      "answer": "The Mediator design pattern is a behavioral pattern that reduces complex communication between multiple objects or classes by introducing a mediator object. This centralizes complex communications and control between related objects, making them less dependent on each other (loosely coupled).\nKey Components:\nMediator: An interface that defines the communication rules between objects.\nConcrete Mediator: Implements the Mediator interface and coordinates communication between Colleague objects.\nColleague: Objects that communicate with each other through the Mediator.",
      "isPremium": false
    },
    {
      "id": 45,
      "level": "Senior",
      "title": "Give an example of the Mediator design pattern.",
      "answer": "Chat Room: A chat room acting as a mediator between users. Users send messages to the chat room, which then forwards these messages to other users.\n\njava\n\nCopy code\n\n// Mediator\ninterface ChatRoomMediator {\n    void showMessage(User user, String message);\n}\n \n// Concrete Mediator\nclass ChatRoom implements ChatRoomMediator {\n    public void showMessage(User user, String message) {\n        System.out.println(user.getName() + \": \" + message);\n    }\n}\n \n// Colleague\nclass User {\n    private String name;\n    private ChatRoomMediator mediator;\n \n    public User(String name, ChatRoomMediator mediator) {\n        this.name = name;\n        this.mediator = mediator;\n    }\n \n    public String getName() {\n        return name;\n    }\n \n    public void send(String message) {\n        mediator.showMessage(this, message);\n    }\n}\n \n// Usage\nChatRoomMediator mediator = new ChatRoom();\nUser john = new User(\"John\", mediator);\nUser jane = new User(\"Jane\", mediator);\n \njohn.send(\"Hi there!\");\njane.send(\"Hey!\");\nIn this example, ChatRoom is the Concrete Mediator, and User acts as Colleague. Users communicate with each other through the chat room (Mediator), which centralizes and simplifies the communication process.",
      "isPremium": false
    },
    {
      "id": 46,
      "level": "Senior",
      "title": "Explain the Memento design pattern.",
      "answer": "The Memento design pattern is a behavioral pattern that captures and externalizes an object's internal state so that the object can be restored to this state later.\nIt allows for the implementation of undo mechanisms while keeping the details of the saved state encapsulated.\nKey Components:\nMemento: A class that stores the internal state of the Originator object. It protects against access by objects other than the originator.\nOriginator: The object whose state is being saved and restored.\nCaretaker: Holds the Memento but does not operate on it or examine its contents.",
      "isPremium": false
    },
    {
      "id": 47,
      "level": "Senior",
      "title": "Give an example of the Memento design pattern.",
      "answer": "Text Editor Undo Functionality: In a text editor, saving the state of a document at various points, so that it can be returned to one of those states.\n\njava\n\nCopy code\n\n// Memento\nclass EditorMemento {\n    private final String content;\n \n    public EditorMemento(String content) {\n        this.content = content;\n    }\n \n    public String getContent() {\n        return content;\n    }\n}\n \n// Originator\nclass Editor {\n    private String content;\n \n    public void setContent(String content) {\n        this.content = content;\n    }\n \n    public EditorMemento save() {\n        return new EditorMemento(content);\n    }\n \n    public void restore(EditorMemento memento) {\n        content = memento.getContent();\n    }\n}\n \n// Caretaker\nclass EditorCaretaker {\n    private EditorMemento memento;\n \n    public void saveState(Editor editor) {\n        memento = editor.save();\n    }\n \n    public void restoreState(Editor editor) {\n        editor.restore(memento);\n    }\n}\n \n// Usage\nEditor editor = new Editor();\nEditorCaretaker caretaker = new EditorCaretaker();\n \neditor.setContent(\"State 1\");\ncaretaker.saveState(editor);\n \neditor.setContent(\"State 2\");\ncaretaker.restoreState(editor); // Restores to \"State 1\"\nIn this example, EditorMemento is the Memento, Editor is the Originator, and EditorCaretaker is the Caretaker. The editor's state is saved in EditorMemento by EditorCaretaker, and it can be restored to this saved state later.",
      "isPremium": false
    },
    {
      "id": 48,
      "level": "Senior",
      "title": "Explain the Chain of Responsibility design pattern.",
      "answer": "The Chain of Responsibility design pattern is a behavioral pattern that passes a request along a chain of handlers. Upon receiving a request, each handler decides either to process it or to pass it to the next handler in the chain.\nThis pattern allows an object to send a command without knowing which object will handle the command.\nKey Components:\nHandler: An interface for handling requests and optionally implementing the successor link.\nConcrete Handler: Handles requests it is responsible for; can access its successor.\nClient: Initiates the request to a Concrete Handler in the chain.",
      "isPremium": false
    },
    {
      "id": 49,
      "level": "Senior",
      "title": "Give an example of the Chain of Responsibility design pattern.",
      "answer": "Customer Support System: Requests for support can be sent to a chain where each handler represents a level of support like front desk, technical support, supervisor, etc. The request is passed along the chain until it is handled.\n\njava\n\nCopy code\n\n// Handler\nabstract class SupportHandler {\n    protected SupportHandler nextHandler;\n \n    public void setNextHandler(SupportHandler nextHandler) {\n        this.nextHandler = nextHandler;\n    }\n \n    public abstract void handleRequest(SupportRequest request);\n}\n \n// Concrete Handlers\nclass FrontDeskSupport extends SupportHandler {\n    public void handleRequest(SupportRequest request) {\n        if (canHandle(request)) {\n            // handle request\n        } else {\n            nextHandler.handleRequest(request);\n        }\n    }\n}\n \nclass TechnicalSupport extends SupportHandler {\n    // handle request or pass it to the next handler\n}\n \n// Client\nclass Client {\n    public static void main(String[] args) {\n        SupportHandler frontDesk = new FrontDeskSupport();\n        SupportHandler techSupport = new TechnicalSupport();\n \n        frontDesk.setNextHandler(techSupport);\n \n        frontDesk.handleRequest(new SupportRequest());\n    }\n}\n\nIn this example, SupportHandler is the Handler, FrontDeskSupport and TechnicalSupport are Concrete Handlers, and the Client is setting up the chain and initiating the request. The request travels along the chain until it finds a handler capable of processing it.",
      "isPremium": false
    },
    {
      "id": 50,
      "level": "Senior",
      "title": "How can you ensure that design patterns do not lead to over-engineering or unnecessary complexity?",
      "answer": "To ensure that design patterns do not lead to over-engineering or unnecessary complexity, it's important to:\nUnderstand the Problem: Apply design patterns only when they address a specific problem or requirement in your project.\nKeep It Simple: Follow the KISS (Keep It Simple, Stupid) principle. Avoid using a pattern for the sake of using it; simplicity often trumps complexity.\nKnowledge of Patterns: Proper understanding of the intent and trade-offs of each pattern helps in choosing the right one for a given situation.\nRefactor as Needed: Be ready to refactor your code if a design pattern starts introducing more complexity than the problem it solves.\nReview and Collaborate: Regular code reviews and discussions with team members can help identify over-engineered solutions.",
      "isPremium": false
    }
  ]
}