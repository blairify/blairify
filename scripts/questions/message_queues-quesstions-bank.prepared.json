{
  "mcq_questions": [],
  "open_questions": [
    {
      "id": "message-queues-quesstions-bank-1",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "A message queue and why would",
      "description": "What is a message queue and why would you use one in a modern system?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"What is a message queue and why would you use one in a modern system?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "entry",
        "junior"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-1-ref-1",
          "text": "A message queue lets one component (the producer) drop messages into a buffer that another component (the consumer) processes later at its own pace. By decoupling sender and receiver, it smooths traffic spikes, isolates microservices for independent scaling or failure, and boosts reliability through retries and persistence when services are down. In cloud and microservice architectures, this asynchronous messaging ensures resilient, flexible data exchange.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "entry"
    },
    {
      "id": "message-queues-quesstions-bank-2",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Es asynchronous messaging via queues differ",
      "description": "How does asynchronous messaging via queues differ from synchronous communication (like direct API calls)?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"How does asynchronous messaging via queues differ from synchronous communication (like direct API calls)?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-2-ref-1",
          "text": "In synchronous calls (e.g., HTTP), the caller waits - blocking - until a downstream service responds, so slow or unavailable services stall the operation. With asynchronous queues, the producer hands off a message to a broker and moves on immediately; consumers process messages later, enabling independent scaling, fault tolerance, and burst buffering at the cost of added complexity (state tracking, idempotency) and eventual consistency.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-3",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Can you explain the difference between",
      "description": "Can you explain the difference between point-to-point messaging and publish-subscribe messaging?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"Can you explain the difference between point-to-point messaging and publish-subscribe messaging?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-scientist",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-3-ref-1",
          "text": "Point‑to‑point messaging sends messages to a designated queue, multiple consumers may listen, but each message is delivered to exactly one (think of a work queue for load‑balanced tasks). Publish‑subscribe uses topics (or exchanges) so every subscriber gets its own copy of each message, making it perfect for broadcasting events or notifications (e.g., triggering different actions in various systems). In short, queues enable one‑to‑one, competing‑consumer workflows, while topics support one‑to‑many message distribution.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-4",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Producers, consumers, and brokers in the",
      "description": "What are producers, consumers, and brokers in the context of message queues?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"What are producers, consumers, and brokers in the context of message queues?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-4-ref-1",
          "text": "Producers (or publishers) create messages and send them to a queue or topic. Consumers (or subscribers) pull and process those messages. The broker (message‑queue server) stores messages, enforces delivery semantics (e.g., guarantees, routing) and mediates between producers and consumers. In systems like RabbitMQ or Kafka, clients connect to the broker, producers send messages into it and consumers fetch them, decoupling senders from receivers.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-5",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Es it mean for a message",
      "description": "What does it mean for a message queue to guarantee durability or persistence of messages?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"What does it mean for a message queue to guarantee durability or persistence of messages?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-engineer",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-5-ref-1",
          "text": "Durability ensures messages survive broker failures by persisting them to disk or replicating them so they remain available after restarts. By declaring queues as durable and marking messages persistent, you guard against data loss, which is vital for critical workflows like financial transactions. Though disk I/O or replication adds overhead compared to fast, in‑memory (transient) messaging, durability markedly boosts system reliability.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-6",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "At-least-once, at-most-once, and exactly-once delivery semantics",
      "description": "What are at-least-once, at-most-once, and exactly-once delivery semantics in messaging?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"What are at-least-once, at-most-once, and exactly-once delivery semantics in messaging?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-6-ref-1",
          "text": "At‑most‑once delivers a message zero or one time with no retries, fast but prone to loss. At‑least‑once retries until the consumer acknowledges, guaranteed delivery but may produce duplicates. Exactly‑once ensures a single delivery with no loss or duplicates, but demands idempotent operations or transactional coordination (e.g., Kafka’s idempotent producers + transactional API), so most systems default to at‑least‑once and rely on consumer‑side deduplication.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-7",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Message queues useful for decoupling and",
      "description": "Why are message queues useful for decoupling and what is an example use case in a DevOps/SRE context?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"Why are message queues useful for decoupling and what is an example use case in a DevOps/SRE context?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "devops",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-7-ref-1",
          "text": "By decoupling senders from receivers, message queues let each component scale or fail independently, improving system robustness. For example, in a continuous deployment pipeline (DevOps scenario), you might have a build service produce messages about new artifacts or tests to run, and multiple workers consume those to perform deployments or run tests asynchronously. In an SRE context, queues are also used for rate smoothing – if one part of the system gets a burst of traffic, a queue can buffer these requests, preventing overload downstream and allowing graceful processing over time. Overall, they enable more robust and maintainable architectures by isolating components.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-8",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Es Apache Kafka differ from a",
      "description": "How does Apache Kafka differ from a traditional message broker like RabbitMQ?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"How does Apache Kafka differ from a traditional message broker like RabbitMQ?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-engineer",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-8-ref-1",
          "text": "Kafka Apache Kafka is a distributed streaming platform that persists ordered logs across partitioned topics, offering high throughput, horizontal scalability, and consumer‑managed offsets for replayable event streams and data pipelines. Kafka’s strength lies in sequential disk writes, fault‑tolerant logs, and long‑term retention, ideal for high‑volume event streaming and history replay. RabbitMQ RabbitMQ is a broker implementing AMQP with exchanges, queues, and flexible routing, delivering discrete messages push‑style with per‑message acknowledgments, retries, and RPC support. RabbitMQ excels at immediate delivery, complex routing patterns, and integration workflows—perfect for task queues and request/response. Choose Kafka for durable, replayable streaming; choose RabbitMQ for feature‑rich, flexible messaging.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-9",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "How consumer groups work in Kafka",
      "description": "Explain how consumer groups work in Kafka and why they are important.?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"Explain how consumer groups work in Kafka and why they are important.?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-engineer",
        "data-scientist",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-9-ref-1",
          "text": "In Kafka, a consumer group is a set of consumers sharing a topic’s workload: each partition is assigned to exactly one consumer in the group, enabling parallel processing and horizontal scaling. If a consumer fails, Kafka rebalances its partitions to other group members, ensuring continuous progress. The group tracks a collective offset per partition, providing Kafka’s ordering guarantee. Multiple groups can independently consume the same topic (broadcast), while within a group each message goes to only one consumer (competing‑consumer), making Kafka both scalable and fault‑tolerant for streaming applications.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-10",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "In RabbitMQ, what is an exchange",
      "description": "In RabbitMQ, what is an exchange and how does it route messages to queues?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"In RabbitMQ, what is an exchange and how does it route messages to queues?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "entry",
        "junior"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-10-ref-1",
          "text": "Producers publish messages to an exchange, not directly to queues, and the exchange routes them based on the message’s routing key and its own type/rules: Direct: Delivers to queues whose binding key exactly matches the routing key (one‑to‑one). Fanout: Broadcasts to all bound queues, ignoring routing keys. Topic: Uses wildcard patterns on routing keys (e.g., “logs.error”) to route to matching queues. Headers: Routes based on header attributes instead of keys. Exchanges let you flexibly direct messages to one or many queues e.g. a topic exchange can broadcast categorized logs to multiple services.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "entry"
    },
    {
      "id": "message-queues-quesstions-bank-11",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Es AWS SQS ensure message delivery,",
      "description": "How does AWS SQS ensure message delivery, and what are the differences between standard SQS and SQS FIFO queues?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"How does AWS SQS ensure message delivery, and what are the differences between standard SQS and SQS FIFO queues?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "devops",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-11-ref-1",
          "text": "Amazon SQS is a fully managed, highly durable queue service that redundantly stores messages across Availability Zones. It offers at‑least‑once delivery, so consumers must handle potential duplicates, and relies on visibility timeouts to hide received messages until they’re processed (or reappear for redelivery if not deleted in time). There are two queue types: Standard: virtually unlimited throughput, at‑least‑once delivery, best‑effort ordering (messages may arrive out of order). FIFO: guarantees first‑in, first‑out ordering and exactly‑once processing via deduplication IDs, with lower throughput and use of message group IDs to enable parallelism while preserving order.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-12",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Google Cloud Pub/Sub and how does",
      "description": "What is Google Cloud Pub/Sub and how does it handle message delivery and subscriber models?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"What is Google Cloud Pub/Sub and how does it handle message delivery and subscriber models?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-scientist",
        "devops",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "entry",
        "junior"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-12-ref-1",
          "text": "Google Cloud Pub/Sub is a fully managed, scalable pub/sub service for asynchronous messaging. Producers publish to topics, and consumers subscribe via: Pull: your application explicitly fetches and acknowledges messages, giving you control over flow and batching. Push: Pub/Sub issues HTTP requests to your endpoint like a webhook, and you acknowledge by returning a success code. By default, Pub/Sub uses at‑least‑once delivery, messages persist across zones and retry until acknowledged, so duplicates can occur. Ordering keys let you enforce in‑order delivery per key. Behind the scenes, it auto‑scales and load‑balances deliveries across subscribers. To achieve exactly‑once semantics, you must handle deduplication or idempotency downstream.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "entry"
    },
    {
      "id": "message-queues-quesstions-bank-13",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "You monitor the health and performance",
      "description": "How would you monitor the health and performance of a message queue system in production?",
      "prompt": "You are evaluating a mid-level candidate. Answer the question: \"How would you monitor the health and performance of a message queue system in production?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 10,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-engineer",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher",
        "competitive"
      ],
      "seniorityLevels": [
        "mid",
        "senior"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-13-ref-1",
          "text": "Queue Depth: Track the number of enqueued messages. A steady growth signals slow or down consumers. Throughput & Lag: Measure messages in/out per second and, in Kafka, consumer lag (latest offset minus consumed offset) to spot backlogs. Processing Latency: Record how long messages wait in the queue and how long consumers take to process them, key for identifying bottlenecks. Error & Dead‑Letter Rates: Monitor failed deliveries and DLQ volumes to catch bugs or poison messages early. Broker Health: Keep an eye on broker CPU, memory, disk I/O (and network I/O for log‑based systems) plus internal metrics (e.g., Kafka JMX, RabbitMQ socket/channel counts). Alerting & Synthetic Tests: Define alerts for thresholds (e.g., queue length, no active consumers, high error rates) and periodically publish/consume test messages to verify end‑to‑end flow. Tooling: Use Prometheus/Grafana (ingesting JMX or management‑API metrics) or vendor dashboards to collect, visualize, and alert on all of the above.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "mid"
    },
    {
      "id": "message-queues-quesstions-bank-14",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "A dead-letter queue (DLQ) and how",
      "description": "What is a dead-letter queue (DLQ) and how is it used in message systems?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"What is a dead-letter queue (DLQ) and how is it used in message systems?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "entry",
        "junior"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-14-ref-1",
          "text": "A dead‑letter queue (DLQ) is a safety‑net queue for messages that can’t be delivered or processed, preventing system stalls or data loss. Messages are routed to a DLQ when they exceed retry limits, are malformed, or hit TTL/queue‑size limits. For example, SQS can forward messages after a max‑receive count, and RabbitMQ can dead‑letter rejected or expired messages via exchanges. Teams then inspect DLQs to debug or requeue fixed messages, isolating problematic traffic and boosting overall reliability.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "entry"
    },
    {
      "id": "message-queues-quesstions-bank-15",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "You handle a situation where producers",
      "description": "How do you handle a situation where producers are much faster than consumers (backpressure)?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"How do you handle a situation where producers are much faster than consumers (backpressure)?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "mid",
        "senior"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-15-ref-1",
          "text": "Rate limiting: Throttle producers when queue depth exceeds thresholds—either in‑app (producers poll queue length) or via broker backpressure signals. Scale consumers: Spin up more consumer processes or, in Kafka, add instances to a consumer group (as partitions allow). Partition or shard: Distribute messages across multiple queues or Kafka partitions so more consumers can work in parallel. Boost throughput: Batch messages, tune broker settings (e.g., Kafka’s batch size/linger), or add broker resources (nodes, faster disks). Backpressure protocols: Use frameworks like Reactive Streams where consumers signal their capacity upstream. Overflow storage: Redirect excess traffic to secondary queues or external storage for later processing if brokers can’t expand. Root‑cause analysis: Distinguish spikes from chronic load—apply auto‑scaling and capacity planning or re‑architect if needed.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "mid"
    },
    {
      "id": "message-queues-quesstions-bank-16",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Es it mean for a consumer",
      "description": "What does it mean for a consumer to be idempotent, and why is that important in at-least-once delivery systems?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"What does it mean for a consumer to be idempotent, and why is that important in at-least-once delivery systems?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-16-ref-1",
          "text": "An idempotent consumer produces the same outcome no matter how many times it processes a message—duplicate deliveries have no extra side effects (e.g., double charges or repeated records). This is essential in at‑least‑once systems (like most queues and Kafka), where retries or lost acknowledgments can lead to repeated messages. To implement idempotency, consumers typically: Track processed message IDs (in a cache or database) and skip repeats. Use deduplication caches keyed by unique message IDs. Perform inherently idempotent operations (e.g., UPSERTs or setting values rather than incrementing). By handling duplicates safely, idempotent consumers underpin exactly‑once semantics and ensure system correctness in distributed messaging environments.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-17",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Es Kafka achieve exactly-once processing semantics",
      "description": "How does Kafka achieve exactly-once processing semantics?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"How does Kafka achieve exactly-once processing semantics?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-engineer",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-17-ref-1",
          "text": "Kafka achieves exactly‑once processing via two key features: Idempotent producers When enabled, producers tag each message with a sequence number so that broker retries don’t create duplicates in a partition. Transactions Producers and consumers can wrap their reads and writes in a transaction—using Kafka’s transactional API and read‑committed isolation—to ensure that a group of operations either all succeed or all fail. For example, a Kafka Streams app can atomically consume from one topic and produce to another, guaranteeing one output per input even if failures trigger retries. End‑to‑end exactly‑once requires: Idempotent producers. Transactional reads/writes with read‑committed consumers. Idempotent or transactional handling in downstream systems (e.g., using UPSERTs in a database) so that consumer‑side retries don’t cause duplicate side effects. Alone, Kafka’s broker still delivers at‑least‑once—these client‑side mechanisms are what make exactly‑once semantics possible.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-18",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "You design a highly available message",
      "description": "How would you design a highly available message queue system across multiple data centers (e.g., active-active or active-passive)?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"How would you design a highly available message queue system across multiple data centers (e.g., active-active or active-passive)?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-scientist",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-18-ref-1",
          "text": "Active‑Passive (Disaster Recovery): Maintain a primary cluster in DC A and a standby in DC B, replicating via Kafka MirrorMaker or RabbitMQ shovel/federation. Clients fail over to B if A fails. Simpler to implement but incurs replication lag and non‑instant failover. Active‑Active (Geo‑Distributed): Run clusters in both DCs with cross‑cluster replication (e.g., Kafka’s MirrorMaker, RabbitMQ federation). Each site handles local traffic for resilience and throughput. You trade off consistency—potential duplicates or out‑of‑order delivery—against availability. Quorum‑based Replication: Use consensus (e.g., Apache Pulsar or Kafka’s multi‑region tools) so writes require acknowledgments from nodes in multiple DCs before confirming to producers. This gives strong cross‑site durability but adds write latency. Key considerations: network latency/bandwidth, CAP trade‑offs (consistency vs. availability during partitions), and intelligent client routing (to nearest or healthy cluster). In practice, many opt for automated active‑passive failover or active‑active with eventual consistency.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-19",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Can you explain Kafka’s internal architecture,",
      "description": "Can you explain Kafka’s internal architecture, specifically how it uses partitions, replicas, and what roles ZooKeeper (or KRaft) play?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"Can you explain Kafka’s internal architecture, specifically how it uses partitions, replicas, and what roles ZooKeeper (or KRaft) play?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-engineer",
        "data-scientist",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-19-ref-1",
          "text": "Kafka organizes data into topics split across one or more partitions—each an ordered, append‑only log. Partitions are replicated across brokers: one leader handles all producer writes while followers mirror its log. If the leader fails, an in‑sync follower is elected, ensuring redundancy. Your durability guarantees come from configuring the replication factor and how many in‑sync replicas must acknowledge a write. Cluster metadata (brokers, topics, partitions, leaders) was once managed by ZooKeeper for leader elections and membership. Newer Kafka versions use KRaft, a built‑in Raft‑based consensus layer, eliminating the external ZooKeeper dependency and improving metadata scalability. In practice, producers append to leader logs, followers replicate them, and consumers read messages by offset. Combined, partitioning for parallelism, replication for fault tolerance, and coordinated metadata via ZooKeeper or KRaft, Kafka achieves its signature high throughput, resilience, and scalability.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-20",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "RabbitMQ clustering: how does RabbitMQ achieve",
      "description": "RabbitMQ clustering: how does RabbitMQ achieve high availability?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"RabbitMQ clustering: how does RabbitMQ achieve high availability?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-scientist",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-20-ref-1",
          "text": "Default clustering: Queues live on the node where they’re declared; other nodes merely route to it. If that node fails, the queue is unavailable. Classic mirrored queues: You specify mirrors on other nodes; every publish, consume, and ack is replicated. If the primary dies, a mirror is promoted—no data loss but extra disk and network I/O. Quorum queues: Use a Raft‑based log replicated across a quorum of nodes. Writes require majority acknowledgement, offering stronger durability, simpler failover handling, and resilience to partitions. Client failover: Applications should be configured to reconnect to any healthy node. Both mirrored and quorum queues replicate data to keep queues available and intact when nodes fail, ensuring high availability in RabbitMQ clusters.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-21",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Backpressure in messaging systems, and how",
      "description": "What is backpressure in messaging systems, and how might Kafka or other systems handle it at a protocol level?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"What is backpressure in messaging systems, and how might Kafka or other systems handle it at a protocol level?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-engineer",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "mid",
        "senior"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-21-ref-1",
          "text": "Backpressure lets a system prevent overload by signaling when consumers can’t keep up, rather than letting queues grow unbounded. Different systems implement it as follows: Kafka (pull‑based): Consumers fetch at their own pace, so producers can append until retention limits. Brokers apply implicit backpressure via memory pressure: if the producer’s buffer.memory or broker queues fill up, send() blocks or errors, signaling the producer to slow down. RabbitMQ (push‑based, AMQP): Prefetch (consumer credit): limits unacknowledged messages per consumer, once reached, the broker pauses deliveries until acks arrive. Broker flow control: if queues grow too large, RabbitMQ throttles or blocks producers at the TCP/channel level until consumers catch up. Other protocols: Reactive Streams/Akka: explicit demand signaling, consumers request N items, and producers must not exceed that. Cloud Pub/Sub (push): slows delivery when subscribers return errors, effectively invoking backpressure. Across all systems, backpressure can be proactive (signaling producers to slow) or reactive (throttling or, as a last resort, dropping/offloading messages). Proper handling means configuring clients to respect these signals, e.g., tuning Kafka producer buffer limits and handling QueueFullException, or setting appropriate RabbitMQ prefetch counts, to maintain stability and avoid resource exhaustion.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "mid"
    },
    {
      "id": "message-queues-quesstions-bank-22",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Dealing with millions of messages per",
      "description": "When dealing with millions of messages per minute, what considerations and optimizations would you apply to a message queue system?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"When dealing with millions of messages per minute, what considerations and optimizations would you apply to a message queue system?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "frontend",
        "fullstack",
        "mobile"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-22-ref-1",
          "text": "Partitioning & Sharding: Split topics or queues across many partitions or shards so multiple brokers and consumers can process in parallel. Cluster Scaling: Horizontally add broker nodes (e.g., more Kafka brokers or federated/sharded RabbitMQ nodes) to distribute load and avoid single‑node bottlenecks. Hardware & Networking: Use SSD/NVMe drives for fast I/O, ample RAM for caching, and high‑bandwidth networking (10 GbE+) to support heavy disk and cluster traffic. Batching & Compression: Group messages into batches (tune Kafka’s batch.size and linger.ms; use RabbitMQ’s async publisher confirms) and enable compression to lower per‑message overhead and reduce wire/disk usage. Ack Optimization: Reduce fsync or ack‑flush frequency, tune Kafka’s replication/acks settings and RabbitMQ’s prefetch and bulk acknowledgments, to minimize disk and network stalls. Client Tuning: Configure producers for async I/O and multiple in‑flight requests; tune consumer fetch sizes and parallel message handling to maximize throughput. Monitoring & Auto‑Scaling: Continuously track metrics (lag, queue depth, broker resource use) and automatically scale consumer pools based on thresholds, with back‑off or alternative buffering strategies if overwhelmed. Tiered Architectures: Use an ingest buffer (e.g., Kafka) feeding multiple downstream pipelines, or adopt systems like Pulsar that separate storage (BookKeeper) from brokers to improve scale and flexibility. By combining horizontal scaling, tuned batching/acks, robust hardware, and proactive monitoring with well‑architected pipelines, you ensure your messaging layer meets extreme throughput demands without single‑point failures.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-23",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "You decide between using a managed",
      "description": "How do you decide between using a managed cloud messaging service (like AWS SQS or Google Pub/Sub) versus running your own (like Kafka or RabbitMQ) for a production system?",
      "prompt": "You are evaluating a mid-level candidate. Answer the question: \"How do you decide between using a managed cloud messaging service (like AWS SQS or Google Pub/Sub) versus running your own (like Kafka or RabbitMQ) for a production system?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 10,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "data-engineer",
        "devops",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher",
        "competitive"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-23-ref-1",
          "text": "Managed Services (e.g., SQS, Pub/Sub, Azure Service Bus) Pros: Zero server ops—provider handles scaling, patching, and fault tolerance; seamless bursts; built‑in durability; tight cloud integration (e.g., SQS→Lambda, Pub/Sub→Cloud Functions). Cons: Limited customization (filtering, ordering, internals); vendor lock‑in; per‑request/data pricing can get expensive at scale. Self‑Managed (e.g., Kafka, RabbitMQ, ActiveMQ) Pros: Total configuration control—choose versions, plugins, retention policies, cluster topologies; deploy hybrid or cloud‑agnostic. Cons: Full operational burden—installing, monitoring, upgrading, scaling; requires deep expertise to maintain HA and troubleshoot under load. Cloud‑Managed OSS (e.g., Amazon MSK, CloudAMQP) Pros: Provider‑managed infrastructure with familiar Kafka/RabbitMQ APIs and feature sets. Cons: Higher costs; may lag on new versions or advanced features. Decision Factors: Scale & Throughput: Simple queues at moderate volume → managed service; large, replayable event streams → self‑managed Kafka. Team Expertise & Ops Capacity: Limited ops resources → managed; strong DevOps/Kafka team → self‑hosted. Feature Needs: Need ordering, filtering, replay → choose a system that natively supports them. Latency, SLAs & Cost: Balance performance requirements against pricing models and operational overhead.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-24",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "Some security best practices for message",
      "description": "What are some security best practices for message queue systems (like Kafka, RabbitMQ, etc.)?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"What are some security best practices for message queue systems (like Kafka, RabbitMQ, etc.)?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "cybersecurity",
        "data-engineer",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "junior",
        "mid"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-24-ref-1",
          "text": "Authentication: Require producers and consumers to prove their identity. Kafka: Enable SASL (e.g., SCRAM, OAuth) or mTLS. RabbitMQ: Use built‑in credentials or integrate with LDAP/OAuth. Cloud services: Rely on IAM roles or managed credentials. Authorization: Grant only the permissions each client needs. Kafka: Use ACLs to control publish/consume access per topic. RabbitMQ: Leverage vhosts and user permissions on exchanges/queues. Principle of least privilege: Restrict actions to the bare minimum. Encryption in Transit: Always use TLS/SSL for broker‑client connections to prevent eavesdropping. Encryption at Rest: Secure on‑disk data with disk‑ or log‑level encryption (either broker‑native or via managed‑service defaults). Network Security: Isolate brokers on private networks or behind firewalls/security groups. Restrict access to application servers only; separate prod and non‑prod environments. Monitoring & Auditing: Log authentication/authorization events (e.g., Kafka auth failures, RabbitMQ audit logs). Use IDS/IPS and regularly review credentials and permissions. Patch Management: Keep broker software up to date—apply security patches promptly. For managed services, monitor provider advisories and recommended configurations. By enforcing strong authN/authZ, encrypting data in flight and at rest, locking down network access, auditing activity, and staying patched, you protect your messaging layer from unauthorized access and data breaches.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "junior"
    },
    {
      "id": "message-queues-quesstions-bank-25",
      "status": "published",
      "reviewerId": null,
      "reviewedAt": null,
      "isDemoMode": false,
      "companyType": [
        "faang",
        "startup",
        "enterprise"
      ],
      "title": "A poison message and how should",
      "description": "What is a poison message and how should one handle it in a messaging system?",
      "prompt": "You are evaluating a junior-level candidate. Answer the question: \"What is a poison message and how should one handle it in a messaging system?\" Requirements: - Define the concept in your own words - Give a small example - Mention a common pitfall or best practice Style: - Clear, structured, concise. - Use code snippets only if they add clarity. - Avoid vague statements.",
      "topic": "fullstack",
      "subtopics": [
        "language-fundamentals"
      ],
      "tags": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "estimatedTimeMinutes": 7,
      "aiEvaluationHint": "Expect the answer to address: Define the concept in your own words; Give a small example; Mention a common pitfall or best practice. Penalize answers that miss key requirements.",
      "companies": null,
      "positions": [
        "backend",
        "frontend",
        "fullstack"
      ],
      "primaryTechStack": [
        "message-queues",
        "message-queues-quesstions-bank"
      ],
      "interviewTypes": [
        "regular",
        "practice",
        "flash",
        "teacher"
      ],
      "seniorityLevels": [
        "entry",
        "junior"
      ],
      "createdAt": "2025-12-19T17:51:19.394Z",
      "updatedAt": "2025-12-19T17:51:19.394Z",
      "createdBy": "admin",
      "referenceAnswers": [
        {
          "id": "message-queues-quesstions-bank-25-ref-1",
          "text": "A poison message is one that a consumer can’t process—bad format or content that always fails—and if retried indefinitely it can crash or block the consumer. Common handling strategies: Dead‑Letter Queue: After N failed attempts, automatically move the message to a DLQ to unblock normal processing. Error‑Handling Logic: Catch processing exceptions; decide to nack (requeue or dead‑letter) or ack&drop based on failure type. Automated Retries with Backoff: Retry transient failures (e.g., temporary DB outage) with exponential backoff, then DLQ after X attempts. Validation Upstream: Enforce schemas (Avro/JSON schema) at the producer to reject malformed messages before they enter the queue. Alerting & Analysis: Trigger alerts when messages hit the DLQ, inspect payloads to diagnose producer bugs or unexpected inputs, and improve the system to prevent future occurrences. These patterns ensure that one bad message doesn’t halt the entire pipeline, isolating failures for later review while keeping the rest of the system flowing.",
          "weight": 1,
          "keyPoints": [
            "Define the concept in your own words",
            "Give a small example",
            "Mention a common pitfall or best practice"
          ]
        }
      ],
      "difficulty": "entry"
    }
  ],
  "truefalse_questions": [],
  "matching_questions": [],
  "system_design_questions": []
}
